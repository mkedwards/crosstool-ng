From 9cac6a5cca1ed4ba0ab55208ce018aff1a2dfada Mon Sep 17 00:00:00 2001
From: Michael Edwards <michaedw@michaedw-vbox-amd64.(none)>
Date: Wed, 17 Mar 2010 17:19:57 -0700
Subject: [PATCH] Debian/Ubuntu net-tools 1.60-23ubuntu2 (in patched/configured state)

---
 arp.c                  |  100 +-
 config.h               |   75 ++
 config.in              |   30 +-
 config.make            |   36 +
 configure              |  173 +++
 hostname.c             |   26 +-
 ifconfig.c             |  124 ++-
 include/interface.h    |    6 +-
 include/mii.h          |   23 +-
 include/util-ank.h     |    2 +-
 ipmaddr.c              |   11 +-
 lib/Makefile           |    2 +-
 lib/ddp_gr.c           |   73 ++-
 lib/ec_hw.c            |    2 +
 lib/ether.c            |    4 +-
 lib/eui64.c            |  155 +++
 lib/fddi.c             |    1 +
 lib/hw.c               |   18 +-
 lib/ib.c               |  147 +++
 lib/inet.c             |    6 +-
 lib/inet6.c            |   31 +-
 lib/inet6_gr.c         |   48 +-
 lib/inet_sr.c          |    2 +-
 lib/interface.c        |  147 ++-
 lib/ipx.c              |    3 +
 lib/ipx_gr.c           |   20 +-
 lib/irda.c             |   10 +-
 lib/net-features.h     |    7 +
 lib/nstrcmp.c          |  175 +++-
 lib/pathnames.h        |    8 +-
 lib/proc.c             |   22 +-
 lib/proc.h             |    8 +-
 lib/tr.c               |   20 +-
 lib/util-ank.c         |    2 +-
 lib/util.h             |    3 +
 lib/x25_sr.c           |    6 +-
 man/de_DE/arp.8        |   22 +-
 man/de_DE/hostname.1   |   10 +-
 man/de_DE/ifconfig.8   |   10 +-
 man/de_DE/netstat.8    |   56 +-
 man/de_DE/plipconfig.8 |    2 +-
 man/de_DE/rarp.8       |   10 +-
 man/de_DE/route.8      |   44 +-
 man/de_DE/slattach.8   |   28 +-
 man/en_US/arp.8        |  170 ++-
 man/en_US/ethers.5     |    6 +-
 man/en_US/hostname.1   |   10 +-
 man/en_US/ifconfig.8   |   46 +-
 man/en_US/mii-tool.8   |   29 +-
 man/en_US/nameif.8     |   10 +-
 man/en_US/netstat.8    |   56 +-
 man/en_US/rarp.8       |   16 +-
 man/en_US/route.8      |   55 +-
 man/en_US/slattach.8   |   35 +-
 man/fr_FR/arp.8        |   32 +-
 man/fr_FR/hostname.1   |   18 +-
 man/fr_FR/ifconfig.8   |   18 +-
 man/fr_FR/netstat.8    |   61 +-
 man/fr_FR/rarp.8       |   14 +-
 man/fr_FR/route.8      |   34 +-
 man/fr_FR/slattach.8   |   26 +-
 man/pt_BR/arp.8        |   22 +-
 man/pt_BR/hostname.1   |   10 +-
 man/pt_BR/ifconfig.8   |   10 +-
 man/pt_BR/netstat.8    |   48 +-
 man/pt_BR/rarp.8       |   12 +-
 man/pt_BR/route.8      |   26 +-
 mii-tool.c             |  143 ++-
 nameif.c               |   20 +-
 netstat.c              |  246 +++--
 po/Makefile            |    6 +-
 po/cs.po               | 2278 +++++++++++++++++++++++-------------
 po/de.po               | 2473 ++++++++++++++++++++++++--------------
 po/et_EE.po            | 1303 ++++++++++++++-------
 po/fr.po               | 2387 +++++++++++++++++++++++--------------
 po/ja.po               | 3133 ++++++++++++++++++++++++++++++++++++++++++++++++
 po/net-tools.pot       | 1143 +++++++++++++------
 po/pt_BR.po            | 2371 +++++++++++++++++++++++--------------
 rarp.c                 |    5 +-
 route.c                |   12 +-
 slattach.c             |    8 +-
 statistics.c           |  235 ++++-
 82 files changed, 13144 insertions(+), 5091 deletions(-)
 create mode 100644 config.h
 create mode 100644 config.make
 create mode 100755 configure
 create mode 100644 lib/eui64.c
 create mode 100644 lib/ib.c
 create mode 100644 po/ja.po

diff --git a/arp.c b/arp.c
index 509a804..72015fb 100644
--- a/arp.c
+++ b/arp.c
@@ -8,7 +8,7 @@
  *              NET-3 Networking Distribution for the LINUX operating
  *              system.
  *
- * Version:     $Id: arp.c,v 1.20 2001/04/08 17:05:05 pb Exp $
+ * Version:     $Id: arp.c,v 1.25 2005/12/04 02:57:15 ecki Exp $
  *
  * Maintainer:  Bernd 'eckes' Eckenfels, <net-tools@lina.inka.de>
  *
@@ -100,9 +100,10 @@ static int arp_del(char **args)
 {
     char host[128];
     struct arpreq req;
-    struct sockaddr sa;
+    struct sockaddr_storage ss;
+    struct sockaddr *sa;
     int flags = 0;
-    int err;
+    int deleted = 0;
 
     memset((char *) &req, 0, sizeof(req));
 
@@ -112,12 +113,13 @@ static int arp_del(char **args)
 	return (-1);
     }
     safe_strncpy(host, *args, (sizeof host));
-    if (ap->input(0, host, &sa) < 0) {
+    sa = (struct sockaddr *)&ss;
+    if (ap->input(0, host, sa) < 0) {
 	ap->herror(host);
 	return (-1);
     }
     /* If a host has more than one address, use the correct one! */
-    memcpy((char *) &req.arp_pa, (char *) &sa, sizeof(struct sockaddr));
+    memcpy((char *) &req.arp_pa, (char *) sa, sizeof(struct sockaddr));
 
     if (hw_set)
 	req.arp_ha.sa_family = hw->type;
@@ -148,7 +150,7 @@ static int arp_del(char **args)
 	    continue;
 	}
 	if (!strcmp(*args, "dontpub")) {
-#ifdef HAVE_ATF_DONTPUB
+#ifdef ATF_DONTPUB
 	    req.arp_flags |= ATF_DONTPUB;
 #else
 	    ENOSUPP("arp", "ATF_DONTPUB");
@@ -157,7 +159,7 @@ static int arp_del(char **args)
 	    continue;
 	}
 	if (!strcmp(*args, "auto")) {
-#ifdef HAVE_ATF_MAGIC
+#ifdef ATF_MAGIC
 	    req.arp_flags |= ATF_MAGIC;
 #else
 	    ENOSUPP("arp", "ATF_MAGIC");
@@ -177,11 +179,11 @@ static int arp_del(char **args)
 		usage();
 	    if (strcmp(*args, "255.255.255.255") != 0) {
 		strcpy(host, *args);
-		if (ap->input(0, host, &sa) < 0) {
+		if (ap->input(0, host, sa) < 0) {
 		    ap->herror(host);
 		    return (-1);
 		}
-		memcpy((char *) &req.arp_netmask, (char *) &sa,
+		memcpy((char *) &req.arp_netmask, (char *) sa,
 		       sizeof(struct sockaddr));
 		req.arp_flags |= ATF_NETMASK;
 	    }
@@ -190,35 +192,41 @@ static int arp_del(char **args)
 	}
 	usage();
     }
+
+    // if neighter priv nor pub is given, work on both
     if (flags == 0)
 	flags = 3;
 
     strcpy(req.arp_dev, device);
 
-    err = -1;
+    /* unfortuatelly the kernel interface does not allow us to
+       delete private entries anlone, so we need this hack
+       to avoid "not found" errors if we try both. */
+    deleted = 0;
 
     /* Call the kernel. */
     if (flags & 2) {
 	if (opt_v)
-	    fprintf(stderr, "arp: SIOCDARP(nopub)\n");
-	if ((err = ioctl(sockfd, SIOCDARP, &req) < 0)) {
-	    if (errno == ENXIO) {
+	    fprintf(stderr, "arp: SIOCDARP(dontpub)\n");
+	if (ioctl(sockfd, SIOCDARP, &req) < 0) {
+	    if ((errno == ENXIO) || (errno == ENOENT)) {
 		if (flags & 1)
-		    goto nopub;
+		    goto dontpub;
 		printf(_("No ARP entry for %s\n"), host);
 		return (-1);
 	    }
-	    perror("SIOCDARP(priv)");
+	    perror("SIOCDARP(dontpub)");
 	    return (-1);
-	}
+	} else
+	  deleted = 1;
     }
-    if ((flags & 1) && (err)) {
-      nopub:
+    if (!deleted && (flags & 1)) {
+      dontpub:
 	req.arp_flags |= ATF_PUBL;
 	if (opt_v)
 	    fprintf(stderr, "arp: SIOCDARP(pub)\n");
 	if (ioctl(sockfd, SIOCDARP, &req) < 0) {
-	    if (errno == ENXIO) {
+	    if ((errno == ENXIO) || (errno == ENOENT)) {
 		printf(_("No ARP entry for %s\n"), host);
 		return (-1);
 	    }
@@ -235,7 +243,8 @@ static int arp_getdevhw(char *ifname, struct sockaddr *sa, struct hwtype *hw)
     struct ifreq ifr;
     struct hwtype *xhw;
 
-    strcpy(ifr.ifr_name, ifname);
+    strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+    ifr.ifr_name[IFNAMSIZ-1]='\0';
     if (ioctl(sockfd, SIOCGIFHWADDR, &ifr) < 0) {
 	fprintf(stderr, _("arp: cant get HW-Address for `%s': %s.\n"), ifname, strerror(errno));
 	return (-1);
@@ -260,7 +269,8 @@ static int arp_set(char **args)
 {
     char host[128];
     struct arpreq req;
-    struct sockaddr sa;
+    struct sockaddr_storage ss;
+    struct sockaddr *sa;
     int flags;
 
     memset((char *) &req, 0, sizeof(req));
@@ -271,12 +281,13 @@ static int arp_set(char **args)
 	return (-1);
     }
     safe_strncpy(host, *args++, (sizeof host));
-    if (ap->input(0, host, &sa) < 0) {
+    sa = (struct sockaddr *)&ss;
+    if (ap->input(0, host, sa) < 0) {
 	ap->herror(host);
 	return (-1);
     }
     /* If a host has more than one address, use the correct one! */
-    memcpy((char *) &req.arp_pa, (char *) &sa, sizeof(struct sockaddr));
+    memcpy((char *) &req.arp_pa, (char *) sa, sizeof(struct sockaddr));
 
     /* Fetch the hardware address. */
     if (*args == NULL) {
@@ -317,7 +328,7 @@ static int arp_set(char **args)
 	    continue;
 	}
 	if (!strcmp(*args, "dontpub")) {
-#ifdef HAVE_ATF_DONTPUB
+#ifdef ATF_DONTPUB
 	    flags |= ATF_DONTPUB;
 #else
 	    ENOSUPP("arp", "ATF_DONTPUB");
@@ -326,7 +337,7 @@ static int arp_set(char **args)
 	    continue;
 	}
 	if (!strcmp(*args, "auto")) {
-#ifdef HAVE_ATF_MAGIC
+#ifdef ATF_MAGIC
 	    flags |= ATF_MAGIC;
 #else
 	    ENOSUPP("arp", "ATF_MAGIC");
@@ -346,11 +357,11 @@ static int arp_set(char **args)
 		usage();
 	    if (strcmp(*args, "255.255.255.255") != 0) {
 		strcpy(host, *args);
-		if (ap->input(0, host, &sa) < 0) {
+		if (ap->input(0, host, sa) < 0) {
 		    ap->herror(host);
 		    return (-1);
 		}
-		memcpy((char *) &req.arp_netmask, (char *) &sa,
+		memcpy((char *) &req.arp_netmask, (char *) sa,
 		       sizeof(struct sockaddr));
 		flags |= ATF_NETMASK;
 	    }
@@ -445,11 +456,11 @@ static void arp_disp_2(char *name, int type, int arp_flags, char *hwa, char *mas
 	strcat(flags, "M");
     if (arp_flags & ATF_PUBL)
 	strcat(flags, "P");
-#ifdef HAVE_ATF_MAGIC
+#ifdef ATF_MAGIC
     if (arp_flags & ATF_MAGIC)
 	strcat(flags, "A");
 #endif
-#ifdef HAVE_ATF_DONTPUB
+#ifdef ATF_DONTPUB
     if (arp_flags & ATF_DONTPUB)
 	strcat(flags, "!");
 #endif
@@ -463,7 +474,7 @@ static void arp_disp_2(char *name, int type, int arp_flags, char *hwa, char *mas
 
     if (!(arp_flags & ATF_COM)) {
 	if (arp_flags & ATF_PUBL)
-	    printf("%-8.8s%-20.20s", "*", "*");
+	    printf("%-8.8s%-20.20s", "*", _("<from_interface>"));
 	else
 	    printf("%-8.8s%-20.20s", "", _("(incomplete)"));
     } else {
@@ -486,7 +497,7 @@ static void arp_disp(char *name, char *ip, int type, int arp_flags, char *hwa, c
 
     if (!(arp_flags & ATF_COM)) {
 	if (arp_flags & ATF_PUBL)
-	    printf("* ");
+	    printf("<from_interface> ");
 	else
 	    printf(_("<incomplete> "));
     } else {
@@ -499,12 +510,12 @@ static void arp_disp(char *name, char *ip, int type, int arp_flags, char *hwa, c
     if (arp_flags & ATF_PERM)
 	printf("PERM ");
     if (arp_flags & ATF_PUBL)
-	printf("PUP ");
-#ifdef HAVE_ATF_MAGIC
+	printf("PUB ");
+#ifdef ATF_MAGIC
     if (arp_flags & ATF_MAGIC)
 	printf("AUTO ");
 #endif
-#ifdef HAVE_ATF_DONTPUB
+#ifdef ATF_DONTPUB
     if (arp_flags & ATF_DONTPUB)
 	printf("DONTPUB ");
 #endif
@@ -519,7 +530,8 @@ static void arp_disp(char *name, char *ip, int type, int arp_flags, char *hwa, c
 static int arp_show(char *name)
 {
     char host[100];
-    struct sockaddr sa;
+    struct sockaddr_storage ss;
+    struct sockaddr *sa;
     char ip[100];
     char hwa[100];
     char mask[100];
@@ -532,14 +544,15 @@ static int arp_show(char *name)
 
     host[0] = '\0';
 
+    sa = (struct sockaddr *)&ss;
     if (name != NULL) {
 	/* Resolve the host name. */
 	safe_strncpy(host, name, (sizeof host));
-	if (ap->input(0, host, &sa) < 0) {
+	if (ap->input(0, host, sa) < 0) {
 	    ap->herror(host);
 	    return (-1);
 	}
-	safe_strncpy(host, ap->sprint(&sa, 1), sizeof(host));
+	safe_strncpy(host, ap->sprint(sa, 1), sizeof(host));
     }
     /* Open the PROCps kernel table. */
     if ((fp = fopen(_PATH_PROCNET_ARP, "r")) == NULL) {
@@ -575,10 +588,10 @@ static int arp_show(char *name)
 	    if (opt_n)
 		hostname = "?";
 	    else {
-		if (ap->input(0, ip, &sa) < 0)
+		if (ap->input(0, ip, sa) < 0)
 		    hostname = ip;
 		else
-		    hostname = ap->sprint(&sa, opt_n | 0x8000);
+		    hostname = ap->sprint(sa, opt_n | 0x8000);
 		if (strcmp(hostname, ip) == 0)
 		    hostname = "?";
 	    }
@@ -612,11 +625,10 @@ static void version(void)
 static void usage(void)
 {
     fprintf(stderr, _("Usage:\n  arp [-vn]  [<HW>] [-i <if>] [-a] [<hostname>]             <-Display ARP cache\n"));
-    fprintf(stderr, _("  arp [-v]          [-i <if>] -d  <hostname> [pub][nopub]    <-Delete ARP entry\n"));
-    fprintf(stderr, _("  arp [-vnD] [<HW>] [-i <if>] -f  [<filename>]              <-Add entry from file\n"));
-    fprintf(stderr, _("  arp [-v]   [<HW>] [-i <if>] -s  <hostname> <hwaddr> [temp][nopub] <-Add entry\n"));
-    fprintf(stderr, _("  arp [-v]   [<HW>] [-i <if>] -s  <hostname> <hwaddr> [netmask <nm>] pub  <-''-\n"));
-    fprintf(stderr, _("  arp [-v]   [<HW>] [-i <if>] -Ds <hostname> <if> [netmask <nm>] pub      <-''-\n\n"));
+    fprintf(stderr, _("  arp [-v]          [-i <if>] -d  <host> [pub]               <-Delete ARP entry\n"));
+    fprintf(stderr, _("  arp [-vnD] [<HW>] [-i <if>] -f  [<filename>]            <-Add entry from file\n"));
+    fprintf(stderr, _("  arp [-v]   [<HW>] [-i <if>] -s  <host> <hwaddr> [temp]            <-Add entry\n"));
+    fprintf(stderr, _("  arp [-v]   [<HW>] [-i <if>] -Ds <host> <if> [netmask <nm>] pub          <-''-\n\n"));
     
     fprintf(stderr, _("        -a                       display (all) hosts in alternative (BSD) style\n"));
     fprintf(stderr, _("        -s, --set                set a new ARP entry\n"));
diff --git a/config.h b/config.h
new file mode 100644
index 0000000..b73ea08
--- /dev/null
+++ b/config.h
@@ -0,0 +1,75 @@
+/*
+* config.h	Automatically generated configuration includefile
+*
+* NET-TOOLS	A collection of programs that form the base set of the
+*		NET-3 Networking Distribution for the LINUX operating
+*		system.
+*
+*		DO  NOT  EDIT  DIRECTLY
+*
+*/
+
+/* 
+ * 
+ * Internationalization
+ * 
+ * The net-tools package has currently been translated to French,
+ * German and Brazilian Portugese.  Other translations are, of
+ * course, welcome.  Answer `n' here if you have no support for
+ * internationalization on your system.
+ * 
+ */
+#define I18N 1
+
+/* 
+ * 
+ * Protocol Families.
+ * 
+ */
+#define HAVE_AFUNIX 1
+#define HAVE_AFINET 1
+#define HAVE_AFINET6 1
+#define HAVE_AFIPX 1
+#define HAVE_AFATALK 1
+#define HAVE_AFAX25 1
+#define HAVE_AFNETROM 1
+#define HAVE_AFROSE 1
+#define HAVE_AFX25 1
+#define HAVE_AFECONET 1
+#define HAVE_AFDECnet 1
+#define HAVE_AFASH 1
+
+/* 
+ * 
+ * Device Hardware types.
+ * 
+ */
+#define HAVE_HWETHER 1
+#define HAVE_HWARC 1
+#define HAVE_HWSLIP 1
+#define HAVE_HWPPP 1
+#define HAVE_HWTUNNEL 1
+#define HAVE_HWSTRIP 1
+#define HAVE_HWTR 1
+#define HAVE_HWAX25 1
+#define HAVE_HWROSE 1
+#define HAVE_HWNETROM 1
+#define HAVE_HWX25 1
+#define HAVE_HWFR 1
+#define HAVE_HWSIT 1
+#define HAVE_HWFDDI 1
+#define HAVE_HWHIPPI 1
+#define HAVE_HWASH 1
+#define HAVE_HWHDLCLAPB 1
+#define HAVE_HWIRDA 1
+#define HAVE_HWEC 1
+#define HAVE_HWEUI64 1
+
+/* 
+ * 
+ * Other Features.
+ * 
+ */
+#define HAVE_FW_MASQUERADE 1
+#define HAVE_IP_TOOLS 1
+#define HAVE_MII 1
diff --git a/config.in b/config.in
index f3310d6..69a2c48 100644
--- a/config.in
+++ b/config.in
@@ -49,16 +49,16 @@ bool 'Does your system support GNU gettext?' I18N n
 * 
 bool 'UNIX protocol family' HAVE_AFUNIX y
 bool 'INET (TCP/IP) protocol family' HAVE_AFINET y
-bool 'INET6 (IPv6) protocol family' HAVE_AFINET6 n
+bool 'INET6 (IPv6) protocol family' HAVE_AFINET6 y
 bool 'Novell IPX/SPX protocol family' HAVE_AFIPX y
 bool 'Appletalk DDP protocol family' HAVE_AFATALK y
 bool 'AX25 (packet radio) protocol family' HAVE_AFAX25 y
 bool 'NET/ROM (packet radio) protocol family' HAVE_AFNETROM y
-bool 'Rose (packet radio) protocol family' HAVE_AFROSE n
+bool 'Rose (packet radio) protocol family' HAVE_AFROSE y
 bool 'X.25 (CCITT) protocol family' HAVE_AFX25 y
-bool 'Econet protocol family' HAVE_AFECONET n
+bool 'Econet protocol family' HAVE_AFECONET y
 bool 'DECnet protocol family' HAVE_AFDECnet n
-bool 'Ash protocol family' HAVE_AFASH n
+bool 'Ash protocol family' HAVE_AFASH y
 *
 *
 *            Device Hardware types.
@@ -71,21 +71,23 @@ bool 'IPIP Tunnel support' HAVE_HWTUNNEL y
 bool 'STRIP (Metricom radio) support' HAVE_HWSTRIP y
 bool 'Token ring (generic) support' HAVE_HWTR y
 bool 'AX25 (packet radio) support' HAVE_HWAX25 y
-bool 'Rose (packet radio) support' HAVE_HWROSE n
+bool 'Rose (packet radio) support' HAVE_HWROSE y
 bool 'NET/ROM (packet radio) support' HAVE_HWNETROM y
 bool 'X.25 (generic) support' HAVE_HWX25 y
 bool 'DLCI/FRAD (frame relay) support' HAVE_HWFR y
-bool 'SIT (IPv6-in-IPv4) support' HAVE_HWSIT n
-bool 'FDDI (generic) support' HAVE_HWFDDI n
-bool 'HIPPI (generic) support' HAVE_HWHIPPI n
-bool 'Ash hardware support' HAVE_HWASH n
-bool '(Cisco)-HDLC/LAPB support' HAVE_HWHDLCLAPB n
+bool 'SIT (IPv6-in-IPv4) support' HAVE_HWSIT y
+bool 'FDDI (generic) support' HAVE_HWFDDI y
+bool 'HIPPI (generic) support' HAVE_HWHIPPI y
+bool 'Ash hardware support' HAVE_HWASH y
+bool '(Cisco)-HDLC/LAPB support' HAVE_HWHDLCLAPB y
 bool 'IrDA support' HAVE_HWIRDA y
-bool 'Econet hardware support' HAVE_HWEC n
+bool 'Econet hardware support' HAVE_HWEC y
+bool 'Generic EUI-64 hardware support' HAVE_HWEUI64 y
+bool 'InfiniBand hardware support' HAVE_HWIB y
 *
 *
 *           Other Features.
 *
-bool 'IP Masquerading support' HAVE_FW_MASQUERADE n
-bool 'Build iptunnel and ipmaddr' HAVE_IP_TOOLS n
-bool 'Build mii-tool' HAVE_MII n
+bool 'IP Masquerading support' HAVE_FW_MASQUERADE y
+bool 'Build iptunnel and ipmaddr' HAVE_IP_TOOLS y
+bool 'Build mii-tool' HAVE_MII y
diff --git a/config.make b/config.make
new file mode 100644
index 0000000..df0451f
--- /dev/null
+++ b/config.make
@@ -0,0 +1,36 @@
+I18N=1
+HAVE_AFUNIX=1
+HAVE_AFINET=1
+HAVE_AFINET6=1
+HAVE_AFIPX=1
+HAVE_AFATALK=1
+HAVE_AFAX25=1
+HAVE_AFNETROM=1
+HAVE_AFROSE=1
+HAVE_AFX25=1
+HAVE_AFECONET=1
+HAVE_AFDECnet=1
+HAVE_AFASH=1
+HAVE_HWETHER=1
+HAVE_HWARC=1
+HAVE_HWSLIP=1
+HAVE_HWPPP=1
+HAVE_HWTUNNEL=1
+HAVE_HWSTRIP=1
+HAVE_HWTR=1
+HAVE_HWAX25=1
+HAVE_HWROSE=1
+HAVE_HWNETROM=1
+HAVE_HWX25=1
+HAVE_HWFR=1
+HAVE_HWSIT=1
+HAVE_HWFDDI=1
+HAVE_HWHIPPI=1
+HAVE_HWASH=1
+HAVE_HWHDLCLAPB=1
+HAVE_HWIRDA=1
+HAVE_HWEC=1
+HAVE_EUI64=1
+HAVE_FW_MASQUERADE=1
+HAVE_IP_TOOLS=1
+HAVE_MII=1
diff --git a/configure b/configure
new file mode 100755
index 0000000..9859b59
--- /dev/null
+++ b/configure
@@ -0,0 +1,173 @@
+#!/usr/bin/env bash
+#
+# Configure.sh	Generates interactively a config.h from config.in
+#
+# net-tools	A collection of programs that form the base set of the
+#		NET-3 Networking Distribution for the LINUX operating
+#		system.
+#
+# Usage:	Install.sh [--nobackup] [--test]
+#
+# Version:	Install.sh 1.65	(1996-01-12)
+#
+# Authors:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
+#		Johannes Grosen, <grosen@argv.cs.ndsu.nodak.edu>
+#		Copyright 1988-1993 MicroWalt Corporation
+#
+# Modified:
+#        {1.65} Bernd eckes Eckenfels <net-tools@lina.inka.de>
+#		some layout cleanups, slattach/plipconfig removed.
+#		--test for testinstallations added.
+#
+#		This program is free software; you can redistribute it
+#		and/or  modify it under  the terms of  the GNU General
+#		Public  License as  published  by  the  Free  Software
+#		Foundation;  either  version 2 of the License, or  (at
+#		your option) any later version.
+#
+#
+# Make sure we're really running bash.
+#
+# I would really have preferred to write this script in a language with
+# better string handling, but alas, bash is the only scripting language
+# that I can be reasonable sure everybody has on their Linux machine.
+#
+
+CONFIG=config.h
+MAKECONFIG=config.make
+
+
+[ -z "$BASH" ] && { echo "Configure requires bash" 1>&2; exit 1; }
+
+# Disable filename globbing once and for all.
+# Enable function cacheing.
+set -f -h
+
+# set up reading of config file
+if [ "$#" != "1" ] || [ ! -f "$1" ]; then
+	echo "usage: $0 configfile" 1>&2
+	exit 1
+fi
+exec 7<$1
+config_fd_redir='<&7'
+
+#
+# readln reads a line into $ans.
+#
+#	readln prompt default
+#
+function readln()
+{
+  echo -n "$1"
+  IFS='@' read ans || exit 1
+  [ -z "$ans" ] && ans=$2
+}
+
+# bool processes a boolean argument
+#
+#	bool tail
+#
+function bool()
+{
+  # Slimier hack to get bash to rescan a line.
+  eval "set -- $1"
+  ans=""
+  while [ "$ans" != "y" -a "$ans" != "n" ]
+  do
+	readln "$1 ($2) [$3] " "$3"
+  done
+  if [ "$ans" = "y" ]; then
+	echo "#define $2 1" >>${CONFIG}
+	echo "$2=1" >>${MAKECONFIG}
+    else
+	echo "#define $2 0" >>${CONFIG}
+	echo "# $2=0" >> ${MAKECONFIG}
+  fi
+  raw_input_line="bool '$1' $2 $ans"
+  eval "$2=$ans"
+}
+
+# int processes an integer argument
+#
+#	int tail
+#
+function int()
+{
+  # Slimier hack to get bash to rescan a line.
+  eval "set -- $1"
+  ans="x"
+  while [ $[$ans+0] != "$ans" ];
+  do
+	readln "$1 ($2) [$3] " "$3"
+  done
+  echo "#define $2 ($ans)" >>${CONFIG}
+  raw_input_line="int '$1' $2 $ans"
+  eval "$2=$ans"
+}
+
+  #
+  # Make sure we start out with a clean slate.
+  #
+  > config.new
+  > ${CONFIG}
+  > ${MAKECONFIG}
+
+  stack=''
+  branch='t'
+
+  while IFS='@' eval read raw_input_line ${config_fd_redir}
+  do
+	# Slimy hack to get bash to rescan a line.
+	read cmd rest <<-END_OF_COMMAND
+		$raw_input_line
+	END_OF_COMMAND
+
+	if [ "$cmd" = "*" ]; then
+		if [ "$branch" = "t" ]; then
+			echo "$raw_input_line"
+			# echo "# $rest" >>$CONFIG
+			if [ "$prevcmd" != "*" ]; then
+				echo >>${CONFIG}
+				echo "/* $rest" >>${CONFIG}
+			else
+				echo " * $rest" >>${CONFIG}
+			fi
+			prevcmd="*"
+		fi
+	else
+		[ "$prevcmd" = "*" ] && echo " */" >>${CONFIG}
+		prevcmd=""
+		case "$cmd" in
+		=)	[ "$branch" = "t" ] && echo "$rest" >>${CONFIG};;
+		:)	[ "$branch" = "t" ] && echo "$raw_input_line" ;;
+		int)	[ "$branch" = "t" ] && int "$rest" ;;
+		bool)	[ "$branch" = "t" ] && bool "$rest" ;;
+		exec)	[ "$branch" = "t" ] && ( sh -c "$rest" ) ;;
+		if)	stack="$branch $stack"
+			if [ "$branch" = "t" ] && eval "$rest"; then
+				branch=t
+			else
+				branch=f
+			fi ;;
+		else)	if [ "$branch" = "t" ]; then
+				branch=f
+			else
+				read branch rest <<-END_OF_STACK
+					$stack
+				END_OF_STACK
+			fi ;;
+		fi)	[ -z "$stack" ] && echo "Error!  Extra fi." 1>&2
+			read branch stack <<-END_OF_STACK
+				$stack
+			END_OF_STACK
+			;;
+		esac
+	fi
+	echo "$raw_input_line" >>config.new
+  done
+  [ "$prevcmd" = "*" ] && echo " */" >>${CONFIG}
+
+  [ -z "$stack" ] || echo "Error!  Unterminated if." 1>&2
+
+  mv config.new config.status
+  exit 0
diff --git a/hostname.c b/hostname.c
index 8793fb9..c4c5aa0 100644
--- a/hostname.c
+++ b/hostname.c
@@ -9,20 +9,19 @@
  *              dnsdmoainname   
  *              nisdomainname {name|-F file}
  *
- * Version:     hostname 1.96 (1996-02-18)
+ * Version:     hostname 1.101 (2003-10-11)
  *
  * Author:      Peter Tobias <tobias@et-inf.fho-emden.de>
  *
  * Changes:
- *      {1.90}  Peter Tobias :          Added -a and -i options.
- *      {1.91}  Bernd Eckenfels :       -v,-V rewritten, long_opts 
- *                                      (major rewrite), usage.
- *960120 {1.95} Bernd Eckenfels :       -y/nisdomainname - support for get/
- *                                      setdomainname added 
- *960218 {1.96} Bernd Eckenfels :       netinet/in.h added
- *980629 {1.97} Arnaldo Carvalho de Melo : gettext instead of catgets for i18n
- *20000213 {1.99} Arnaldo Carvalho de Melo : fixed some i18n strings
+ *         {1.90}  Peter Tobias : Added -a and -i options.
+ *         {1.91}  Bernd Eckenfels : -v,-V rewritten, long_opts (major rewrite), usage.
+ *19960120 {1.95}  Bernd Eckenfels : -y/nisdomainname - support for get/setdomainname added 
+ *19960218 {1.96}  Bernd Eckenfels : netinet/in.h added
+ *19980629 {1.97}  Arnaldo Carvalho de Melo : gettext instead of catgets for i18n
+ *20000213 {1.99}  Arnaldo Carvalho de Melo : fixed some i18n strings
  *20010404 {1.100} Arnaldo Carvalho de Melo: use setlocale
+ *20031011 {1.101} Maik Broemme: gcc 3.x fixes (default: break)
  *
  *              This program is free software; you can redistribute it
  *              and/or  modify it under  the terms of  the GNU General
@@ -31,7 +30,9 @@
  *              your option) any later version.
  */
 #include <stdio.h>
+#include <stdlib.h>
 #include <unistd.h>
+#include <stdlib.h>
 #include <getopt.h>
 #include <string.h>
 #include <netdb.h>
@@ -78,6 +79,7 @@ static void setnname(char *nname)
             fprintf(stderr, _("%s: name too long\n"), program_name);
             break;
         default:
+	    break;
         }
 	exit(1);
     }
@@ -97,7 +99,6 @@ static void sethname(char *hname)
 	case EINVAL:
 	    fprintf(stderr, _("%s: name too long\n"), program_name);
 	    break;
-	default:
 	}
 	exit(1);
     };
@@ -116,7 +117,6 @@ static void setdname(char *dname)
 	case EINVAL:
 	    fprintf(stderr, _("%s: name too long\n"), program_name);
 	    break;
-	default:
 	}
 	exit(1);
     };
@@ -173,7 +173,6 @@ static void showhname(char *hname, int c)
 	    *p = '\0';
 	printf("%s\n", hp->h_name);
 	break;
-    default:
     }
 }
 
@@ -326,11 +325,12 @@ int main(int argc, char **argv)
 	    break;
 	case 'V':
 	    version();
+	    break; // not reached
 	case '?':
 	case 'h':
 	default:
 	    usage();
-
+	    break; // not reached
 	};
 
 
diff --git a/ifconfig.c b/ifconfig.c
index 73a4e9b..ab3f621 100644
--- a/ifconfig.c
+++ b/ifconfig.c
@@ -3,7 +3,7 @@
  *              that either displays or sets the characteristics of
  *              one or more of the system's networking interfaces.
  *
- * Version:     $Id: ifconfig.c,v 1.50 2001/04/13 18:25:18 pb Exp $
+ * Version:     $Id: ifconfig.c,v 1.58 2008/10/02 23:31:04 ecki Exp $
  *
  * Author:      Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
  *              and others.  Copyright 1993 MicroWalt Corporation
@@ -88,7 +88,6 @@ struct in6_ifreq {
 char *Release = RELEASE, *Version = "ifconfig 1.42 (2001-04-13)";
 
 int opt_a = 0;			/* show all interfaces          */
-int opt_i = 0;			/* show the statistics          */
 int opt_v = 0;			/* debugging output flag        */
 
 int addr_family = 0;		/* currently selected AF        */
@@ -105,7 +104,7 @@ static int if_print(char *ifname)
     int res;
 
     if (ife_short)
-	printf(_("Iface   MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\n"));
+	printf(_("Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\n"));
 
     if (!ifname) {
 	res = for_all_interfaces(do_if_print, &opt_a);
@@ -113,6 +112,9 @@ static int if_print(char *ifname)
 	struct interface *ife;
 
 	ife = lookup_interface(ifname);
+	if (!ife) {
+		return -1;
+	}
 	res = do_if_fetch(ife); 
 	if (res >= 0) 
 	    ife_print(ife);
@@ -127,7 +129,7 @@ static int set_flag(char *ifname, short flag)
 
     safe_strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
     if (ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0) {
-	fprintf(stderr, _("%s: unknown interface: %s\n"), 
+	fprintf(stderr, _("%s: ERROR while getting interface flags: %s\n"), 
 		ifname,	strerror(errno));
 	return (-1);
     }
@@ -159,7 +161,7 @@ static int clr_flag(char *ifname, short flag)
 
     safe_strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
     if (ioctl(fd, SIOCGIFFLAGS, &ifr) < 0) {
-	fprintf(stderr, _("%s: unknown interface: %s\n"), 
+	fprintf(stderr, _("%s: ERROR while getting interface flags: %s\n"), 
 		ifname, strerror(errno));
 	return -1;
     }
@@ -172,9 +174,35 @@ static int clr_flag(char *ifname, short flag)
     return (0);
 }
 
+/** test is a specified flag is set */
+static int test_flag(char *ifname, short flags)
+{
+    struct ifreq ifr;
+    int fd;
+
+    if (strchr(ifname, ':')) {
+        /* This is a v4 alias interface.  Downing it via a socket for
+	   another AF may have bad consequences. */
+        fd = get_socket_for_af(AF_INET);
+	if (fd < 0) {
+	    fprintf(stderr, _("No support for INET on this system.\n"));
+	    return -1;
+	}
+    } else
+        fd = skfd;
+
+    safe_strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
+    if (ioctl(fd, SIOCGIFFLAGS, &ifr) < 0) {
+	fprintf(stderr, _("%s: ERROR while testing interface flags: %s\n"), 
+		ifname, strerror(errno));
+	return -1;
+    }
+    return (ifr.ifr_flags & flags);
+}
+
 static void usage(void)
 {
-    fprintf(stderr, _("Usage:\n  ifconfig [-a] [-i] [-v] [-s] <interface> [[<AF>] <address>]\n"));
+    fprintf(stderr, _("Usage:\n  ifconfig [-a] [-v] [-s] <interface> [[<AF>] <address>]\n"));
 #if HAVE_AFINET
     fprintf(stderr, _("  [add <address>[/<prefixlen>]]\n"));
     fprintf(stderr, _("  [del <address>[/<prefixlen>]]\n"));
@@ -208,7 +236,7 @@ static void usage(void)
 static void version(void)
 {
     fprintf(stderr, "%s\n%s\n", Release, Version);
-    exit(0);
+    exit(E_USAGE);
 }
 
 static int set_netmask(int skfd, struct ifreq *ifr, struct sockaddr *sa)
@@ -222,18 +250,19 @@ static int set_netmask(int skfd, struct ifreq *ifr, struct sockaddr *sa)
 		strerror(errno));
 	err = 1;
     }
-    return 0;
+    return err;
 }
 
 int main(int argc, char **argv)
 {
     struct sockaddr sa;
+    struct sockaddr samask;
     struct sockaddr_in sin;
     char host[128];
     struct aftype *ap;
     struct hwtype *hw;
     struct ifreq ifr;
-    int goterr = 0, didnetmask = 0;
+    int goterr = 0, didnetmask = 0, neednetmask=0;
     char **spp;
     int fd;
 #if HAVE_AFINET6
@@ -388,6 +417,8 @@ int main(int argc, char **argv)
 	}
 	if (!strcmp(*spp, "-promisc")) {
 	    goterr |= clr_flag(ifr.ifr_name, IFF_PROMISC);
+	    if (test_flag(ifr.ifr_name, IFF_PROMISC) > 0)
+	    	fprintf(stderr, _("Warning: Interface %s still in promisc mode... maybe other application is running?\n"), ifr.ifr_name);
 	    spp++;
 	    continue;
 	}
@@ -398,6 +429,8 @@ int main(int argc, char **argv)
 	}
 	if (!strcmp(*spp, "-multicast")) {
 	    goterr |= clr_flag(ifr.ifr_name, IFF_MULTICAST);
+	    if (test_flag(ifr.ifr_name, IFF_MULTICAST) > 0)
+	    	fprintf(stderr, _("Warning: Interface %s still in MULTICAST mode.\n"), ifr.ifr_name);
 	    spp++;
 	    continue;
 	}
@@ -408,6 +441,8 @@ int main(int argc, char **argv)
 	}
 	if (!strcmp(*spp, "-allmulti")) {
 	    goterr |= clr_flag(ifr.ifr_name, IFF_ALLMULTI);
+	    if (test_flag(ifr.ifr_name, IFF_MULTICAST) > 0)
+	    	fprintf(stderr, _("Warning: Interface %s still in ALLMULTI mode.\n"), ifr.ifr_name);
 	    spp++;
 	    continue;
 	}
@@ -430,6 +465,8 @@ int main(int argc, char **argv)
 	if (!strcmp(*spp, "-dynamic")) {
 	    goterr |= clr_flag(ifr.ifr_name, IFF_DYNAMIC);
 	    spp++;
+	    if (test_flag(ifr.ifr_name, IFF_MULTICAST) > 0)
+	    	fprintf(stderr, _("Warning: Interface %s still in DYNAMIC mode.\n"), ifr.ifr_name);
 	    continue;
 	}
 #endif
@@ -486,6 +523,8 @@ int main(int argc, char **argv)
 
 	if (!strcmp(*spp, "-broadcast")) {
 	    goterr |= clr_flag(ifr.ifr_name, IFF_BROADCAST);
+	    if (test_flag(ifr.ifr_name, IFF_MULTICAST) > 0)
+	    	fprintf(stderr, _("Warning: Interface %s still in BROADCAST mode.\n"), ifr.ifr_name);
 	    spp++;
 	    continue;
 	}
@@ -493,7 +532,10 @@ int main(int argc, char **argv)
 	    if (*++spp != NULL) {
 		safe_strncpy(host, *spp, (sizeof host));
 		if (ap->input(0, host, &sa) < 0) {
-		    ap->herror(host);
+		    if (ap->herror)
+		    	ap->herror(host);
+		    else
+		    	fprintf(stderr, _("ifconfig: Error resolving '%s' for broadcast\n"), host);
 		    goterr = 1;
 		    spp++;
 		    continue;
@@ -515,7 +557,10 @@ int main(int argc, char **argv)
 		usage();
 	    safe_strncpy(host, *spp, (sizeof host));
 	    if (ap->input(0, host, &sa) < 0) {
-		ap->herror(host);
+		    if (ap->herror)
+		    	ap->herror(host);
+		    else
+		    	fprintf(stderr, _("ifconfig: Error resolving '%s' for dstaddr\n"), host);
 		goterr = 1;
 		spp++;
 		continue;
@@ -535,13 +580,16 @@ int main(int argc, char **argv)
 		usage();
 	    safe_strncpy(host, *spp, (sizeof host));
 	    if (ap->input(0, host, &sa) < 0) {
-		ap->herror(host);
+		    if (ap->herror)
+		    	ap->herror(host);
+		    else
+		    	fprintf(stderr, _("ifconfig: Error resolving '%s' for netmask\n"), host);
 		goterr = 1;
 		spp++;
 		continue;
 	    }
 	    didnetmask++;
-	    goterr = set_netmask(ap->fd, &ifr, &sa);
+	    goterr |= set_netmask(ap->fd, &ifr, &sa);
 	    spp++;
 	    continue;
 	}
@@ -613,6 +661,8 @@ int main(int argc, char **argv)
 	if (!strcmp(*spp, "-pointopoint")) {
 	    goterr |= clr_flag(ifr.ifr_name, IFF_POINTOPOINT);
 	    spp++;
+	    if (test_flag(ifr.ifr_name, IFF_MULTICAST) > 0)
+	    	fprintf(stderr, _("Warning: Interface %s still in POINTOPOINT mode.\n"), ifr.ifr_name);
 	    continue;
 	}
 	if (!strcmp(*spp, "pointopoint")) {
@@ -620,7 +670,10 @@ int main(int argc, char **argv)
 		spp++;
 		safe_strncpy(host, *spp, (sizeof host));
 		if (ap->input(0, host, &sa)) {
-		    ap->herror(host);
+		    if (ap->herror)
+		    	ap->herror(host);
+		    else
+		    	fprintf(stderr, _("ifconfig: Error resolving '%s' for pointopoint\n"), host);
 		    goterr = 1;
 		    spp++;
 		    continue;
@@ -661,8 +714,12 @@ int main(int argc, char **argv)
 	    memcpy((char *) &ifr.ifr_hwaddr, (char *) &sa,
 		   sizeof(struct sockaddr));
 	    if (ioctl(skfd, SIOCSIFHWADDR, &ifr) < 0) {
-		fprintf(stderr, "SIOCSIFHWADDR: %s\n",
-			strerror(errno));
+		if (errno == EBUSY)
+			fprintf(stderr, "SIOCSIFHWADDR: %s - you may need to down the interface\n",
+				strerror(errno));
+		else
+			fprintf(stderr, "SIOCSIFHWADDR: %s\n",
+				strerror(errno));
 		goterr = 1;
 	    }
 	    spp++;
@@ -681,12 +738,15 @@ int main(int argc, char **argv)
 			usage();
 		    *cp = 0;
 		} else {
-		    prefix_len = 0;
+		    prefix_len = 128;
 		}
 		safe_strncpy(host, *spp, (sizeof host));
 		if (inet6_aftype.input(1, host, 
 				       (struct sockaddr *) &sa6) < 0) {
-		    inet6_aftype.herror(host);
+		    if (inet6_aftype.herror)
+		    	inet6_aftype.herror(host);
+		    else
+		    	fprintf(stderr, _("ifconfig: Error resolving '%s' for add\n"), host);
 		    goterr = 1;
 		    spp++;
 		    continue;
@@ -771,7 +831,7 @@ int main(int argc, char **argv)
 			usage();
 		    *cp = 0;
 		} else {
-		    prefix_len = 0;
+		    prefix_len = 128;
 		}
 		safe_strncpy(host, *spp, (sizeof host));
 		if (inet6_aftype.input(1, host, 
@@ -800,6 +860,8 @@ int main(int argc, char **argv)
 		}
 		ifr6.ifr6_ifindex = ifr.ifr_ifindex;
 		ifr6.ifr6_prefixlen = prefix_len;
+		if (opt_v)
+			fprintf(stderr, "now deleting: ioctl(SIOCDIFADDR,{ifindex=%d,prefixlen=%ld})\n",ifr.ifr_ifindex,prefix_len);
 		if (ioctl(fd, SIOCDIFADDR, &ifr6) < 0) {
 		    fprintf(stderr, "SIOCDIFADDR: %s\n",
 			    strerror(errno));
@@ -859,7 +921,7 @@ int main(int argc, char **argv)
 		    usage();
 		*cp = 0;
 	    } else {
-		prefix_len = 0;
+		prefix_len = 128;
 	    }
 	    safe_strncpy(host, *spp, (sizeof host));
 	    if (inet6_aftype.input(1, host, (struct sockaddr *) &sa6) < 0) {
@@ -903,7 +965,7 @@ int main(int argc, char **argv)
 	/* FIXME: sa is too small for INET6 addresses, inet6 should use that too, 
 	   broadcast is unexpected */
 	if (ap->getmask) {
-	    switch (ap->getmask(host, &sa, NULL)) {
+	    switch (ap->getmask(host, &samask, NULL)) {
 	    case -1:
 		usage();
 		break;
@@ -911,8 +973,8 @@ int main(int argc, char **argv)
 		if (didnetmask)
 		    usage();
 
-		goterr = set_netmask(skfd, &ifr, &sa);
-		didnetmask++;
+		// remeber to set the netmask from samask later
+		neednetmask = 1;
 		break;
 	    }
 	}
@@ -921,9 +983,11 @@ int main(int argc, char **argv)
 	   exit(1);
 	}
 	if (ap->input(0, host, &sa) < 0) {
-	    ap->herror(host);
-	    fprintf(stderr, _("ifconfig: `--help' gives usage information.\n"));
-	    exit(1);
+	    if (ap->herror)
+	    	ap->herror(host);
+	    else
+	    	fprintf(stderr,_("ifconfig: error resolving '%s' to set address for af=%s\n"), host, ap->name); fprintf(stderr,
+	    _("ifconfig: `--help' gives usage information.\n")); exit(1);
 	}
 	memcpy((char *) &ifr.ifr_addr, (char *) &sa, sizeof(struct sockaddr));
 	{
@@ -980,6 +1044,14 @@ int main(int argc, char **argv)
 	spp++;
     }
 
+    if (neednetmask) {
+	goterr |= set_netmask(skfd, &ifr, &samask);
+	didnetmask++;
+    }
+
+    if (opt_v && goterr)
+    	fprintf(stderr, _("WARNING: at least one error occured. (%d)\n"), goterr);
+
     return (goterr);
 }
 
diff --git a/include/interface.h b/include/interface.h
index f95555c..afc1297 100644
--- a/include/interface.h
+++ b/include/interface.h
@@ -64,13 +64,17 @@ struct interface {
 extern int if_fetch(struct interface *ife);
 
 extern int for_all_interfaces(int (*)(struct interface *, void *), void *);
-extern int free_interface_list(void);
+extern int if_cache_free(void);
 extern struct interface *lookup_interface(char *name);
 extern int if_readlist(void);
 
 extern int do_if_fetch(struct interface *ife);
 extern int do_if_print(struct interface *ife, void *cookie);
 
+extern int    procnetdev_version(char *buf);
+extern int    get_dev_fields(char *bp, struct interface *ife);
+extern char * get_name(char *name, char *p);
+
 extern void ife_print(struct interface *ptr);
 
 extern int ife_short;
diff --git a/include/mii.h b/include/mii.h
index 1ef7ccc..8a26226 100644
--- a/include/mii.h
+++ b/include/mii.h
@@ -6,11 +6,14 @@
  * Copyright (C) 2000 David A. Hinds -- dhinds@pcmcia.sourceforge.org
  */
 
-#ifndef _LINUX_MII_H
-#define _LINUX_MII_H
+#ifndef _NETTOOL_MII_H
+#define _NETTOOLS_MII_H
+
+#include <linux/sockios.h>
 
 /* network interface ioctl's for MII commands */
 #ifndef SIOCGMIIPHY
+#warning "SIOCGMIIPHY is not defined by your kernel source"
 #define SIOCGMIIPHY (SIOCDEVPRIVATE)	/* Read from current PHY */
 #define SIOCGMIIREG (SIOCDEVPRIVATE+1) 	/* Read any PHY register */
 #define SIOCSMIIREG (SIOCDEVPRIVATE+2) 	/* Write any PHY register */
@@ -38,6 +41,7 @@ struct mii_data {
 #define  MII_BMCR_RESTART	0x0200
 #define  MII_BMCR_DUPLEX	0x0100
 #define  MII_BMCR_COLTEST	0x0080
+#define  MII_BMCR_SPEED1000	0x0040
 
 /* Basic Mode Status Register */
 #define MII_BMSR		0x01
@@ -83,4 +87,17 @@ struct mii_data {
 #define  MII_ANER_PAGE_RX	0x0002
 #define  MII_ANER_LP_AN_ABLE	0x0001
 
-#endif /* _LINUX_MII_H */
+#define MII_CTRL1000		0x09
+#define   MII_BMCR2_1000FULL	0x0200
+#define   MII_BMCR2_1000HALF	0x0100
+
+#define MII_STAT1000		0x0a
+#define   MII_LPA2_1000LOCALOK  0x2000
+#define   MII_LPA2_1000REMRXOK	0x1000
+#define   MII_LPA2_1000FULL	0x0800
+#define   MII_LPA2_1000HALF	0x0400
+
+/* Last register we need for show_basic_mii() */
+#define MII_BASIC_MAX          (MII_STAT1000+1)
+
+#endif /* _NETTOOLS_MII_H */
diff --git a/include/util-ank.h b/include/util-ank.h
index 04ab16c..c8fcd08 100644
--- a/include/util-ank.h
+++ b/include/util-ank.h
@@ -75,6 +75,6 @@ extern int do_qdisc(int argc, char **argv);
 extern int do_class(int argc, char **argv);
 extern int do_filter(int argc, char **argv);
 
-extern const char *format_host(int af, void *addr, __u8 *abuf, int alen);
+extern const char *format_host(int af, void *addr, char *abuf, int alen);
 
 #endif /* __UTILS_H__ */
diff --git a/ipmaddr.c b/ipmaddr.c
index 2134e81..89cdc08 100644
--- a/ipmaddr.c
+++ b/ipmaddr.c
@@ -291,13 +291,15 @@ static void print_mlist(FILE *fp, struct ma_info *list)
 static int multiaddr_list(int argc, char **argv)
 {
 	struct ma_info *list = NULL;
+	size_t l;
 
 	while (argc > 0) {
 		if (strcmp(*argv, "dev") == 0) {
 			NEXT_ARG();
-			if (filter_dev[0])
+			l = strlen(*argv);
+			if (l <= 0 || l >= sizeof(filter_dev))
 				usage();
-			strcpy(filter_dev, *argv);
+			strncpy(filter_dev, *argv, sizeof (filter_dev));
 		} else if (strcmp(*argv, "all") == 0) {
 			filter_family = AF_UNSPEC;
 		} else if (strcmp(*argv, "ipv4") == 0) {
@@ -307,9 +309,10 @@ static int multiaddr_list(int argc, char **argv)
 		} else if (strcmp(*argv, "link") == 0) {
 			filter_family = AF_PACKET;
 		} else {
-			if (filter_dev[0])
+			l = strlen(*argv);
+			if (l <= 0 || l >= sizeof(filter_dev))
 				usage();
-			strcpy(filter_dev, *argv);
+			strncpy(filter_dev, *argv, sizeof (filter_dev));
 		}
 		argv++; argc--;
 	}
diff --git a/lib/Makefile b/lib/Makefile
index d714b2e..976ebb8 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -16,7 +16,7 @@
 #
 
 
-HWOBJS	 = hw.o loopback.o slip.o ether.o ax25.o ppp.o arcnet.o tr.o tunnel.o frame.o sit.o rose.o ash.o fddi.o hippi.o hdlclapb.o strip.o irda.o ec_hw.o x25.o
+HWOBJS	 = hw.o loopback.o slip.o ether.o ax25.o ppp.o arcnet.o tr.o tunnel.o frame.o sit.o rose.o ash.o fddi.o hippi.o hdlclapb.o strip.o irda.o ec_hw.o x25.o eui64.o ib.o
 AFOBJS	 = unix.o inet.o inet6.o ax25.o ipx.o ddp.o ipx.o netrom.o af.o rose.o econet.o x25.o
 AFGROBJS = inet_gr.o inet6_gr.o ipx_gr.o ddp_gr.o netrom_gr.o ax25_gr.o rose_gr.o getroute.o x25_gr.o
 AFSROBJS = inet_sr.o inet6_sr.o netrom_sr.o ipx_sr.o setroute.o x25_sr.o
diff --git a/lib/ddp_gr.c b/lib/ddp_gr.c
index 94169f0..3453e2f 100644
--- a/lib/ddp_gr.c
+++ b/lib/ddp_gr.c
@@ -1,3 +1,20 @@
+/*
+ * lib/ddp_gr.c         Prinbting of DDP (AppleTalk) routing table
+ *                      used by the NET-LIB.
+ *
+ * NET-LIB      
+ *
+ * Version:     $Id: ddp_gr.c,v 1.4 2002/06/02 05:25:15 ecki Exp $
+ *
+ * Author:      Ajax <ajax@firest0rm.org>
+ *
+ * Modification:
+ *  2002-06-02 integrated into main source by Bernd Eckenfels
+ *
+ */
+
+/* TODO: name lookups (/etc/atalk.names?  NBP?) */
+
 #include "config.h"
 
 #if HAVE_AFATALK
@@ -16,9 +33,61 @@
 #include "pathnames.h"
 #include "intl.h"
 
+/* stolen from inet_gr.c */
+#define flags_decode(i,o) do {                  \
+        o[0] = '\0';                            \
+        if (i & RTF_UP) strcat(o, "U");         \
+        if (i & RTF_GATEWAY) strcat(o, "G");    \
+        if (i & RTF_REJECT) strcat(o, "!");     \
+        if (i & RTF_HOST) strcat(o, "H");       \
+        if (i & RTF_REINSTATE) strcat(o, "R");  \
+        if (i & RTF_DYNAMIC) strcat(o, "D");    \
+        if (i & RTF_MODIFIED) strcat(o, "M");   \
+        if (i & RTF_DEFAULT) strcat(o, "d");    \
+        if (i & RTF_ALLONLINK) strcat(o, "a");  \
+        if (i & RTF_ADDRCONF) strcat(o, "c");   \
+        if (i & RTF_NONEXTHOP) strcat(o, "o");  \
+        if (i & RTF_EXPIRES) strcat(o, "e");    \
+        if (i & RTF_CACHE) strcat(o, "c");      \
+        if (i & RTF_FLOW) strcat(o, "f");       \
+        if (i & RTF_POLICY) strcat(o, "p");     \
+        if (i & RTF_LOCAL) strcat(o, "l");      \
+        if (i & RTF_MTU) strcat(o, "u");        \
+        if (i & RTF_WINDOW) strcat(o, "w");     \
+        if (i & RTF_IRTT) strcat(o, "i");       \
+        if (i & RTF_NOTCACHED) strcat(o, "n");  \
+    } while (0)
+
 int DDP_rprint(int options)
 {
-    fprintf(stderr, _("Routing table for `ddp' not yet supported.\n"));
-    return (1);
+    FILE *fp;
+    char *dest, *gw, *dev, *flags;
+    char oflags[32];
+    char *hdr = "Destination     Gateway         Device          Flags";
+
+    fp = fopen(_PATH_PROCNET_ATALK_ROUTE, "r");
+
+    if (!fp) {
+        perror("Error opening " _PATH_PROCNET_ATALK_ROUTE);
+        fprintf(stderr, "DDP (AppleTalk) not configured on this system.\n");
+        return 1;
+    }
+
+    fscanf(fp, "%as %as %as %as\n", &dest, &gw, &flags, &dev);
+    free(dest); free(gw); free(dev); free(flags);
+
+    printf("%s\n", hdr);
+
+    while (fscanf(fp, "%as %as %as %as\n", &dest, &gw, &flags, &dev) == 4) {
+        int iflags = atoi(flags);
+        flags_decode(iflags, oflags);
+        printf("%-16s%-16s%-16s%-s\n", dest, gw, dev, oflags);
+        free(dest); free(gw); free(dev); free(flags);
+    }
+
+    fclose(fp);
+    
+    return 0;
+
 }
 #endif
diff --git a/lib/ec_hw.c b/lib/ec_hw.c
index 825e501..caf5c01 100644
--- a/lib/ec_hw.c
+++ b/lib/ec_hw.c
@@ -16,6 +16,8 @@
 
 #if HAVE_HWEC
 
+#include <stddef.h>
+
 #include <net/if_arp.h>
 #include "net-support.h"
 
diff --git a/lib/ether.c b/lib/ether.c
index a71aed7..70a6daf 100644
--- a/lib/ether.c
+++ b/lib/ether.c
@@ -2,7 +2,7 @@
  * lib/ether.c        This file contains an implementation of the "Ethernet"
  *              support functions.
  *
- * Version:     $Id: ether.c,v 1.7 1999/09/27 11:00:47 philip Exp $
+ * Version:     $Id: ether.c,v 1.8 2002/07/30 05:17:29 ecki Exp $
  *
  * Author:      Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
  *              Copyright 1993 MicroWalt Corporation
@@ -39,7 +39,7 @@ static char *pr_ether(unsigned char *ptr)
 {
     static char buff[64];
 
-    snprintf(buff, sizeof(buff), "%02X:%02X:%02X:%02X:%02X:%02X",
+    snprintf(buff, sizeof(buff), "%02x:%02x:%02x:%02x:%02x:%02x",
 	     (ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
 	     (ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377)
 	);
diff --git a/lib/eui64.c b/lib/eui64.c
new file mode 100644
index 0000000..64c3614
--- /dev/null
+++ b/lib/eui64.c
@@ -0,0 +1,155 @@
+/*
+ * lib/eui64.c  This file contains support for generic EUI-64 hw addressing
+ *
+ * Version:     $Id: eui64.c,v 1.1 2001/11/12 02:12:05 ecki Exp $
+ *
+ * Author:      Daniel Stodden <stodden@in.tum.de>
+ *              Copyright 2001 Daniel Stodden
+ *
+ *              blueprinted from ether.c 
+ *              Copyright 1993 MicroWalt Corporation
+ *
+ *              This program is free software; you can redistribute it
+ *              and/or  modify it under  the terms of  the GNU General
+ *              Public  License as  published  by  the  Free  Software
+ *              Foundation;  either  version 2 of the License, or  (at
+ *              your option) any later version.
+ */
+#include "config.h"
+
+#if HAVE_HWEUI64
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <net/if_arp.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+#include "net-support.h"
+#include "pathnames.h"
+#include "intl.h"
+
+/*
+ * EUI-64 constants
+ */
+
+#define EUI64_ALEN	8
+
+#ifndef ARPHRD_EUI64
+#define ARPHRD_EUI64	27
+#warning "ARPHRD_EUI64 not defined in <net/if_arp.h>. Using private value 27"
+#endif
+
+struct hwtype eui64_hwtype;
+
+/* Display an EUI-64 address in readable format. */
+static char *pr_eui64( unsigned char *ptr )
+{
+	static char buff[64];
+
+	snprintf(buff, sizeof(buff), "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X",
+		 (ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377), (ptr[3] & 0377), 
+		 (ptr[4] & 0377), (ptr[5] & 0377), (ptr[6] & 0377), (ptr[7] & 0377)
+		);
+	return (buff);
+}
+
+/* Start the PPP encapsulation on the file descriptor. */
+static int in_eui64( char *bufp, struct sockaddr *sap )
+{
+	unsigned char *ptr;
+	char c, *orig;
+	int i;
+	unsigned val;
+
+	sap->sa_family = eui64_hwtype.type;
+	ptr = sap->sa_data;
+
+	i = 0;
+	orig = bufp;
+	
+	while ((*bufp != '\0') && (i < EUI64_ALEN)) {
+		val = 0;
+		c = *bufp++;
+		if (isdigit(c))
+			val = c - '0';
+		else if (c >= 'a' && c <= 'f')
+			val = c - 'a' + 10;
+		else if (c >= 'A' && c <= 'F')
+			val = c - 'A' + 10;
+		else {
+#ifdef DEBUG
+			fprintf( stderr, _("in_eui64(%s): invalid eui64 address!\n"), 
+				 orig );
+#endif
+			errno = EINVAL;
+			return (-1);
+		}
+
+		val <<= 4;
+		c = *bufp;
+		if (isdigit(c))
+			val |= c - '0';
+		else if (c >= 'a' && c <= 'f')
+			val |= c - 'a' + 10;
+		else if (c >= 'A' && c <= 'F')
+			val |= c - 'A' + 10;
+		else if (c == ':' || c == 0)
+			val >>= 4;
+		else {
+#ifdef DEBUG
+			fprintf( stderr, _("in_eui64(%s): invalid eui64 address!\n"), 
+				 orig );
+#endif
+			errno = EINVAL;
+			return (-1);
+		}
+
+		if (c != 0)
+			bufp++;
+
+		*ptr++ = (unsigned char) (val & 0377);
+		i++;
+		
+		/* We might get a semicolon here - not required. */
+		if (*bufp == ':') {
+			if (i == EUI64_ALEN) {
+#ifdef DEBUG
+				fprintf(stderr, _("in_eui64(%s): trailing : ignored!\n"),
+					orig)
+#endif
+					; /* nothing */
+			}
+			bufp++;
+		}
+	}
+
+	/* That's it.  Any trailing junk? */
+	if ((i == EUI64_ALEN) && (*bufp != '\0')) {
+#ifdef DEBUG
+		fprintf(stderr, _("in_eui64(%s): trailing junk!\n"), orig);
+		errno = EINVAL;
+		return (-1);
+#endif
+	}
+#ifdef DEBUG
+	fprintf(stderr, "in_eui64(%s): %s\n", orig, pr_eui64(sap->sa_data));
+#endif
+
+    return (0);
+}
+
+struct hwtype eui64_hwtype =
+{
+	"eui64", NULL, /*"EUI-64 addressing", */ ARPHRD_EUI64, EUI64_ALEN,
+	pr_eui64, in_eui64, NULL, 0
+};
+
+
+#endif				/* HAVE_EUI64 */
diff --git a/lib/fddi.c b/lib/fddi.c
index f6bf5ca..a80dd69 100644
--- a/lib/fddi.c
+++ b/lib/fddi.c
@@ -26,6 +26,7 @@
 #error "No FDDI Support in your current Kernelsource Tree."
 #error "Disable HW Type FDDI"
 #endif
+#include <linux/types.h>
 #if __GLIBC__ >= 2
 #include <netinet/if_fddi.h>
 #else
diff --git a/lib/hw.c b/lib/hw.c
index 4989748..e9ba0be 100644
--- a/lib/hw.c
+++ b/lib/hw.c
@@ -2,7 +2,7 @@
  * lib/hw.c   This file contains the top-level part of the hardware
  *              support functions module.
  *
- * Version:     $Id: hw.c,v 1.17 2000/05/20 13:38:10 pb Exp $
+ * Version:     $Id: hw.c,v 1.19 2008/10/03 01:52:04 ecki Exp $
  *
  * Maintainer:  Bernd 'eckes' Eckenfels, <net-tools@lina.inka.de>
  *
@@ -73,6 +73,10 @@ extern struct hwtype irda_hwtype;
 
 extern struct hwtype ec_hwtype;
 
+extern struct hwtype ib_hwtype;
+
+extern struct hwtype eui64_hwtype;
+
 static struct hwtype *hwtypes[] =
 {
 
@@ -144,6 +148,12 @@ static struct hwtype *hwtypes[] =
 #if HAVE_HWX25
     &x25_hwtype,
 #endif
+#if HAVE_HWIB
+    &ib_hwtype,
+#endif
+#if HAVE_HWEUI64
+    &eui64_hwtype,
+#endif
     &unspec_hwtype,
     NULL
 };
@@ -217,6 +227,12 @@ void hwinit()
 #if HAVE_HWEC
     ec_hwtype.title = _("Econet");
 #endif
+#if HAVE_HWIB
+    ib_hwtype.title = _("InfiniBand");
+#endif
+#if HAVE_HWEUI64
+    eui64_hwtype.title = _("Generic EUI-64");
+#endif
     sVhwinit = 1;
 }
 
diff --git a/lib/ib.c b/lib/ib.c
new file mode 100644
index 0000000..d5a84d3
--- /dev/null
+++ b/lib/ib.c
@@ -0,0 +1,147 @@
+/*
+ * lib/ib.c        This file contains an implementation of the "Infiniband"
+ *              support functions.
+ *
+ * Version:     $Id: ib.c,v 1.1 2005/02/06 11:00:47 tduffy Exp $
+ *
+ * Author:      Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
+ *              Copyright 1993 MicroWalt Corporation
+ *		Tom Duffy <tduffy@sun.com>
+ *
+ *              This program is free software; you can redistribute it
+ *              and/or  modify it under  the terms of  the GNU General
+ *              Public  License as  published  by  the  Free  Software
+ *              Foundation;  either  version 2 of the License, or  (at
+ *              your option) any later version.
+ */
+#include "config.h"
+
+#if HAVE_HWIB
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/if_arp.h>
+#include <linux/if_infiniband.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <ctype.h>
+#include <string.h>
+#include <unistd.h>
+#include "net-support.h"
+#include "pathnames.h"
+#include "intl.h"
+#include "util.h"
+
+extern struct hwtype ib_hwtype;
+
+
+/* Display an InfiniBand address in readable format. */
+static char *pr_ib(unsigned char *ptr)
+{
+    static char buff[128];
+    char *pos;
+    unsigned int i;
+
+    pos = buff;
+    for (i = 0; i < INFINIBAND_ALEN; i++) {
+	pos += sprintf(pos, "%02X:", (*ptr++ & 0377));
+    }
+    buff[strlen(buff) - 1] = '\0';
+
+    /* snprintf(buff, sizeof(buff), "%02X:%02X:%02X:%02X:%02X:%02X",
+	     (ptr[0] & 0377), (ptr[1] & 0377), (ptr[2] & 0377),
+	     (ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377)
+	);
+    */
+    return (buff);
+}
+
+
+/* Input an Infiniband address and convert to binary. */
+static int in_ib(char *bufp, struct sockaddr *sap)
+{
+    unsigned char *ptr;
+    char c, *orig;
+    int i;
+    unsigned val;
+
+    sap->sa_family = ib_hwtype.type;
+    ptr = sap->sa_data;
+
+    i = 0;
+    orig = bufp;
+    while ((*bufp != '\0') && (i < INFINIBAND_ALEN)) {
+	val = 0;
+	c = *bufp++;
+	if (isdigit(c))
+	    val = c - '0';
+	else if (c >= 'a' && c <= 'f')
+	    val = c - 'a' + 10;
+	else if (c >= 'A' && c <= 'F')
+	    val = c - 'A' + 10;
+	else {
+#ifdef DEBUG
+	    fprintf(stderr, _("in_ib(%s): invalid infiniband address!\n"), orig);
+#endif
+	    errno = EINVAL;
+	    return (-1);
+	}
+	val <<= 4;
+	c = *bufp;
+	if (isdigit(c))
+	    val |= c - '0';
+	else if (c >= 'a' && c <= 'f')
+	    val |= c - 'a' + 10;
+	else if (c >= 'A' && c <= 'F')
+	    val |= c - 'A' + 10;
+	else if (c == ':' || c == 0)
+	    val >>= 4;
+	else {
+#ifdef DEBUG
+	    fprintf(stderr, _("in_ib(%s): invalid infiniband address!\n"), orig);
+#endif
+	    errno = EINVAL;
+	    return (-1);
+	}
+	if (c != 0)
+	    bufp++;
+	*ptr++ = (unsigned char) (val & 0377);
+	i++;
+
+	/* We might get a semicolon here - not required. */
+	if (*bufp == ':') {
+	    if (i == INFINIBAND_ALEN) {
+#ifdef DEBUG
+		fprintf(stderr, _("in_ib(%s): trailing : ignored!\n"),
+			orig)
+#endif
+		    ;		/* nothing */
+	    }
+	    bufp++;
+	}
+    }
+
+    /* That's it.  Any trailing junk? */
+    if ((i == INFINIBAND_ALEN) && (*bufp != '\0')) {
+#ifdef DEBUG
+	fprintf(stderr, _("in_ib(%s): trailing junk!\n"), orig);
+	errno = EINVAL;
+	return (-1);
+#endif
+    }
+#ifdef DEBUG
+    fprintf(stderr, "in_ib(%s): %s\n", orig, pr_ib(sap->sa_data));
+#endif
+
+    return (0);
+}
+
+
+struct hwtype ib_hwtype =
+{
+    "infiniband", NULL, ARPHRD_INFINIBAND, INFINIBAND_ALEN,
+    pr_ib, in_ib, NULL
+};
+
+
+#endif				/* HAVE_HWIB */
diff --git a/lib/inet.c b/lib/inet.c
index ae90664..c0f7efa 100644
--- a/lib/inet.c
+++ b/lib/inet.c
@@ -3,7 +3,7 @@
  *              support functions for the net-tools.
  *              (NET-3 base distribution).
  *
- * Version:    $Id: inet.c,v 1.13 1999/12/11 13:35:56 freitag Exp $
+ * Version:    $Id: inet.c,v 1.14 2003/10/19 11:57:37 pb Exp $
  *
  * Author:      Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
  *              Copyright 1993 MicroWalt Corporation
@@ -144,7 +144,7 @@ static int INET_rresolve(char *name, size_t len, struct sockaddr_in *sin,
     struct hostent *ent;
     struct netent *np;
     struct addr *pn;
-    unsigned long ad, host_ad;
+    u_int32_t ad, host_ad;
     int host = 0;
 
     /* Grmpf. -FvK */
@@ -155,7 +155,7 @@ static int INET_rresolve(char *name, size_t len, struct sockaddr_in *sin,
 	errno = EAFNOSUPPORT;
 	return (-1);
     }
-    ad = (unsigned long) sin->sin_addr.s_addr;
+    ad = sin->sin_addr.s_addr;
 #ifdef DEBUG
     fprintf (stderr, "rresolve: %08lx, mask %08x, num %08x \n", ad, netmask, numeric);
 #endif
diff --git a/lib/inet6.c b/lib/inet6.c
index 1f936b3..9a484a0 100644
--- a/lib/inet6.c
+++ b/lib/inet6.c
@@ -3,7 +3,7 @@
  *              support functions for the net-tools.
  *              (most of it copied from lib/inet.c 1.26).
  *
- * Version:     $Id: inet6.c,v 1.10 2000/10/28 11:04:00 pb Exp $
+ * Version:     $Id: inet6.c,v 1.12 2002/12/10 01:03:09 ecki Exp $
  *
  * Author:      Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
  *              Copyright 1993 MicroWalt Corporation
@@ -44,6 +44,21 @@
 
 extern int h_errno;		/* some netdb.h versions don't export this */
 
+char * fix_v4_address(char *buf, struct in6_addr *in6) 
+{ 
+	if (IN6_IS_ADDR_V4MAPPED(in6->s6_addr)) { 
+			char *s =strchr(buf, '.'); 
+			if (s) { 
+				while (s > buf && *s != ':')
+					--s;
+				if (*s == ':') ++s; 	
+				else s = NULL; 
+			} 	
+			if (s) return s;
+	} 
+	return buf; 
+} 
+
 static int INET6_resolve(char *name, struct sockaddr_in6 *sin6)
 {
     struct addrinfo req, *ai;
@@ -83,14 +98,14 @@ static int INET6_rresolve(char *name, struct sockaddr_in6 *sin6, int numeric)
 	return (-1);
     }
     if (numeric & 0x7FFF) {
-	inet_ntop(AF_INET6, &sin6->sin6_addr, name, 80);
+	inet_ntop( AF_INET6, &sin6->sin6_addr, name, 80);
 	return (0);
     }
     if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
         if (numeric & 0x8000)
 	    strcpy(name, "default");
 	else
-	    strcpy(name, "*");
+	    strcpy(name, "[::]");
 	return (0);
     }
 
@@ -109,13 +124,14 @@ static void INET6_reserror(char *text)
 }
 
 
+
 /* Display an Internet socket address. */
 static char *INET6_print(unsigned char *ptr)
 {
     static char name[80];
 
     inet_ntop(AF_INET6, (struct in6_addr *) ptr, name, 80);
-    return name;
+	return fix_v4_address(name, (struct in6_addr *)ptr);
 }
 
 
@@ -129,13 +145,14 @@ static char *INET6_sprint(struct sockaddr *sap, int numeric)
 	return safe_strncpy(buff, _("[NONE SET]"), sizeof(buff));
     if (INET6_rresolve(buff, (struct sockaddr_in6 *) sap, numeric) != 0)
 	return safe_strncpy(buff, _("[UNKNOWN]"), sizeof(buff));
-    return (buff);
+    return (fix_v4_address(buff, &((struct sockaddr_in6 *)sap)->sin6_addr));
 }
 
 
 static int INET6_getsock(char *bufp, struct sockaddr *sap)
 {
     struct sockaddr_in6 *sin6;
+	char *p;
 
     sin6 = (struct sockaddr_in6 *) sap;
     sin6->sin6_family = AF_INET6;
@@ -143,7 +160,9 @@ static int INET6_getsock(char *bufp, struct sockaddr *sap)
 
     if (inet_pton(AF_INET6, bufp, sin6->sin6_addr.s6_addr) <= 0)
 	return (-1);
-
+	p = fix_v4_address(bufp, &sin6->sin6_addr);
+	if (p != bufp) 
+		memcpy(bufp, p, strlen(p)+1); 
     return 16;			/* ?;) */
 }
 
diff --git a/lib/inet6_gr.c b/lib/inet6_gr.c
index 14f32eb..7f1bc20 100644
--- a/lib/inet6_gr.c
+++ b/lib/inet6_gr.c
@@ -1,4 +1,4 @@
-/*
+ /*
    Modifications:
    1998-07-01 - Arnaldo Carvalho de Melo - GNU gettext instead of catgets,
    snprintf instead of sprintf
@@ -71,11 +71,15 @@ int rprint_fib6(int ext, int numeric)
         printf(_("INET6 (IPv6) not configured in this system.\n"));
 	return 1;
     }
-    printf(_("Kernel IPv6 routing table\n"));
 
-    printf(_("Destination                                 "
-	     "Next Hop                                "
-	     "Flags Metric Ref    Use Iface\n"));
+    if (numeric & RTF_CACHE)
+    	printf(_("Kernel IPv6 routing cache\n"));
+    else
+    	printf(_("Kernel IPv6 routing table\n"));
+
+    printf(_("Destination                    "
+	     "Next Hop                   "
+	     "Flag Met Ref Use If\n"));
 
     while (fgets(buff, 1023, fp)) {
 	num = sscanf(buff, "%4s%4s%4s%4s%4s%4s%4s%4s %02x %4s%4s%4s%4s%4s%4s%4s%4s %02x %4s%4s%4s%4s%4s%4s%4s%4s %08x %08x %08x %08x %s\n",
@@ -87,13 +91,19 @@ int rprint_fib6(int ext, int numeric)
 		     &slen,
 		     naddr6p[0], naddr6p[1], naddr6p[2], naddr6p[3],
 		     naddr6p[4], naddr6p[5], naddr6p[6], naddr6p[7],
-		     &metric, &use, &refcnt, &iflags, iface);
+		     &metric, &refcnt, &use, &iflags, iface);
 #if 0
 	if (num < 23)
 	    continue;
 #endif
-	if (!(iflags & RTF_UP))
-	    continue;
+	if (iflags & RTF_CACHE) {
+		if (!(numeric & RTF_CACHE))
+			continue;
+	} else {
+		if (numeric & RTF_CACHE)
+			continue;
+	}
+			
 	/* Fetch and resolve the target address. */
 	snprintf(addr6, sizeof(addr6), "%s:%s:%s:%s:%s:%s:%s:%s",
 		 addr6p[0], addr6p[1], addr6p[2], addr6p[3],
@@ -112,7 +122,12 @@ int rprint_fib6(int ext, int numeric)
 		 inet6_aftype.sprint((struct sockaddr *) &snaddr6, 1));
 
 	/* Decode the flags. */
-	strcpy(flags, "U");
+
+	flags[0]=0;
+	if (iflags & RTF_UP)
+	    strcat(flags, "U");
+	if (iflags & RTF_REJECT)
+	    strcat(flags, "!");
 	if (iflags & RTF_GATEWAY)
 	    strcat(flags, "G");
 	if (iflags & RTF_HOST)
@@ -123,9 +138,19 @@ int rprint_fib6(int ext, int numeric)
 	    strcat(flags, "A");
 	if (iflags & RTF_CACHE)
 	    strcat(flags, "C");
+	if (iflags & RTF_ALLONLINK)
+	    strcat(flags, "a");
+	if (iflags & RTF_EXPIRES)
+	    strcat(flags, "e");
+	if (iflags & RTF_MODIFIED)
+	    strcat(flags, "m");
+	if (iflags & RTF_NONEXTHOP)
+	    strcat(flags, "n");
+	if (iflags & RTF_FLOW)
+	    strcat(flags, "f");
 
 	/* Print the info. */
-	printf("%-43s %-39s %-5s %-6d %-2d %7d %-8s\n",
+	printf("%-30s %-26s %-4s %-3d %-1d%6d %s\n",
 	       addr6, naddr6, flags, metric, refcnt, use, iface);
     }
 
@@ -144,8 +169,7 @@ int rprint_cache6(int ext, int numeric)
     char addr6p[8][5], haddrp[6][3];
 
     if (!fp) {
-	ESYSNOT("nd_print", "ND Table");
-	return 1;
+	return rprint_fib6(ext, numeric | RTF_CACHE);
     }
     printf(_("Kernel IPv6 Neighbour Cache\n"));
 
diff --git a/lib/inet_sr.c b/lib/inet_sr.c
index 6d010d5..1a876ae 100644
--- a/lib/inet_sr.c
+++ b/lib/inet_sr.c
@@ -3,6 +3,7 @@
    1998-07-01 - Arnaldo Carvalho de Melo - GNU gettext instead of catgets
    1999-10-07 - Kurt Garloff		 - for -host and gws: prefer host names
 						over networks (or even reject)
+   2003-10-11 - Maik Broemme		 - gcc 3.x warnign fixes (default: break;)
  */
 
 #include "config.h"
@@ -104,7 +105,6 @@ static int INET_setroute(int action, int options, char **args)
        isnet = 1; break;
     case 2:
        isnet = 0; break;
-    default:
     }
 
     /* Fill in the other fields. */
diff --git a/lib/interface.c b/lib/interface.c
index f4d2a9a..23b8a73 100644
--- a/lib/interface.c
+++ b/lib/interface.c
@@ -7,7 +7,7 @@
    8/2000  Andi Kleen make the list operations a bit more efficient.
    People are crazy enough to use thousands of aliases now.
 
-   $Id: interface.c,v 1.14 2001/02/10 19:31:15 pb Exp $
+   $Id: interface.c,v 1.30 2005/08/23 22:46:51 ecki Exp $
  */
 
 #include "config.h"
@@ -23,6 +23,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <ctype.h>
+#include <string.h>
 
 #if HAVE_AFIPX
 #if (__GLIBC__ > 2) || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1)
@@ -87,14 +88,20 @@ int procnetdev_vsn = 1;
 
 int ife_short;
 
+int if_list_all = 0;	/* do we have requested the complete proc list, yet? */
+
 static struct interface *int_list, *int_last;
 
 static int if_readlist_proc(char *);
 
-static struct interface *add_interface(char *name)
+static struct interface *if_cache_add(char *name)
 {
     struct interface *ife, **nextp, *new;
 
+    if (!int_list)
+    	int_last = NULL;
+
+    /* the cache is sorted, so if we hit a smaller if, exit */
     for (ife = int_last; ife; ife = ife->prev) {
 	    int n = nstrcmp(ife->name, name); 
 	    if (n == 0) 
@@ -104,7 +111,7 @@ static struct interface *add_interface(char *name)
     }
     new(new); 
     safe_strncpy(new->name, name, IFNAMSIZ); 
-    nextp = ife ? &ife->next : &int_list;
+    nextp = ife ? &ife->next : &int_list; // keep sorting
     new->prev = ife;
     new->next = *nextp; 
     if (new->next) 
@@ -117,19 +124,22 @@ static struct interface *add_interface(char *name)
 
 struct interface *lookup_interface(char *name)
 {
-    struct interface *ife = NULL;
-
-    if (if_readlist_proc(name) < 0) 
-	    return NULL; 
-    ife = add_interface(name); 
-    return ife;
+   /* if we have read all, use it */
+   if (if_list_all)
+   	return if_cache_add(name);
+
+   /* otherwise we read a limited list */
+   if (if_readlist_proc(name) < 0)
+   	return NULL;
+ 
+   return if_cache_add(name);
 }
 
 int for_all_interfaces(int (*doit) (struct interface *, void *), void *cookie)
 {
     struct interface *ife;
 
-    if (!int_list && (if_readlist() < 0))
+    if (!if_list_all && (if_readlist() < 0))
 	return -1;
     for (ife = int_list; ife; ife = ife->next) {
 	int err = doit(ife, cookie);
@@ -139,13 +149,15 @@ int for_all_interfaces(int (*doit) (struct interface *, void *), void *cookie)
     return 0;
 }
 
-int free_interface_list(void)
+int if_cache_free(void)
 {
     struct interface *ife;
     while ((ife = int_list) != NULL) {
 	int_list = ife->next;
 	free(ife);
     }
+    int_last = NULL;
+    if_list_all = 0;
     return 0;
 }
 
@@ -180,7 +192,7 @@ static int if_readconf(void)
 	}
 	if (ifc.ifc_len == sizeof(struct ifreq) * numreqs) {
 	    /* assume it overflowed and try again */
-	    numreqs += 10;
+	    numreqs *= 2;
 	    continue;
 	}
 	break;
@@ -188,7 +200,7 @@ static int if_readconf(void)
 
     ifr = ifc.ifc_req;
     for (n = 0; n < ifc.ifc_len; n += sizeof(struct ifreq)) {
-	add_interface(ifr->ifr_name);
+	if_cache_add(ifr->ifr_name);
 	ifr++;
     }
     err = 0;
@@ -198,7 +210,7 @@ out:
     return err;
 }
 
-static char *get_name(char *name, char *p)
+char *get_name(char *name, char *p)
 {
     while (isspace(*p))
 	p++;
@@ -206,16 +218,19 @@ static char *get_name(char *name, char *p)
 	if (isspace(*p))
 	    break;
 	if (*p == ':') {	/* could be an alias */
-	    char *dot = p, *dotname = name;
-	    *name++ = *p++;
-	    while (isdigit(*p))
-		*name++ = *p++;
-	    if (*p != ':') {	/* it wasn't, backup */
-		p = dot;
-		name = dotname;
+		char *dot = p++;
+ 		while (*p && isdigit(*p)) p++;
+		if (*p == ':') {
+			/* Yes it is, backup and copy it. */
+			p = dot;
+			*name++ = *p++;
+			while (*p && isdigit(*p)) {
+				*name++ = *p++;
+			}
+		} else {
+			/* No, it isn't */
+			p = dot;
 	    }
-	    if (*p == '\0')
-		return NULL;
 	    p++;
 	    break;
 	}
@@ -225,7 +240,7 @@ static char *get_name(char *name, char *p)
     return p;
 }
 
-static int procnetdev_version(char *buf)
+int procnetdev_version(char *buf)
 {
     if (strstr(buf, "compressed"))
 	return 3;
@@ -234,12 +249,12 @@ static int procnetdev_version(char *buf)
     return 1;
 }
 
-static int get_dev_fields(char *bp, struct interface *ife)
+int get_dev_fields(char *bp, struct interface *ife)
 {
     switch (procnetdev_vsn) {
     case 3:
 	sscanf(bp,
-	"%llu %llu %lu %lu %lu %lu %lu %lu %llu %llu %lu %lu %lu %lu %lu %lu",
+	"%Lu %Lu %lu %lu %lu %lu %lu %lu %Lu %Lu %lu %lu %lu %lu %lu %lu",
 	       &ife->stats.rx_bytes,
 	       &ife->stats.rx_packets,
 	       &ife->stats.rx_errors,
@@ -259,7 +274,7 @@ static int get_dev_fields(char *bp, struct interface *ife)
 	       &ife->stats.tx_compressed);
 	break;
     case 2:
-	sscanf(bp, "%llu %llu %lu %lu %lu %lu %llu %llu %lu %lu %lu %lu %lu",
+	sscanf(bp, "%Lu %Lu %lu %lu %lu %lu %Lu %Lu %lu %lu %lu %lu %lu",
 	       &ife->stats.rx_bytes,
 	       &ife->stats.rx_packets,
 	       &ife->stats.rx_errors,
@@ -277,7 +292,7 @@ static int get_dev_fields(char *bp, struct interface *ife)
 	ife->stats.rx_multicast = 0;
 	break;
     case 1:
-	sscanf(bp, "%llu %lu %lu %lu %lu %llu %lu %lu %lu %lu %lu",
+	sscanf(bp, "%Lu %lu %lu %lu %lu %Lu %lu %lu %lu %lu %lu",
 	       &ife->stats.rx_packets,
 	       &ife->stats.rx_errors,
 	       &ife->stats.rx_dropped,
@@ -300,22 +315,16 @@ static int get_dev_fields(char *bp, struct interface *ife)
 
 static int if_readlist_proc(char *target)
 {
-    static int proc_read; 
     FILE *fh;
     char buf[512];
     struct interface *ife;
     int err;
 
-    if (proc_read) 
-	    return 0; 
-    if (!target) 
-	    proc_read = 1;
-
     fh = fopen(_PATH_PROCNET_DEV, "r");
     if (!fh) {
 		fprintf(stderr, _("Warning: cannot open %s (%s). Limited output.\n"),
 			_PATH_PROCNET_DEV, strerror(errno)); 
-		return if_readconf();
+		return -2;
 	}	
     fgets(buf, sizeof buf, fh);	/* eat line */
     fgets(buf, sizeof buf, fh);
@@ -350,7 +359,7 @@ static int if_readlist_proc(char *target)
     while (fgets(buf, sizeof buf, fh)) {
 	char *s, name[IFNAMSIZ];
 	s = get_name(name, buf);    
-	ife = add_interface(name);
+	ife = if_cache_add(name);
 	get_dev_fields(s, ife);
 	ife->statistics_valid = 1;
 	if (target && !strcmp(target,name))
@@ -359,7 +368,6 @@ static int if_readlist_proc(char *target)
     if (ferror(fh)) {
 	perror(_PATH_PROCNET_DEV);
 	err = -1;
-	proc_read = 0; 
     }
 
 #if 0
@@ -371,9 +379,16 @@ static int if_readlist_proc(char *target)
 
 int if_readlist(void) 
 { 
-    int err = if_readlist_proc(NULL); 
-    if (!err)
-	    err = if_readconf();
+    /* caller will/should check not to call this too often 
+     *   (i.e. only if if_list_all == 0 
+     */
+    int err = 0;
+
+    err |= if_readlist_proc(NULL); 
+    err |= if_readconf();
+
+    if_list_all = 1;
+
     return err;
 } 
 
@@ -579,11 +594,11 @@ int do_if_print(struct interface *ife, void *cookie)
 
 void ife_print_short(struct interface *ptr)
 {
-    printf("%-5.5s ", ptr->name);
-    printf("%5d %3d", ptr->mtu, ptr->metric);
+    printf("%-9s ", ptr->name);
+    printf("%5d %-2d ", ptr->mtu, ptr->metric);
     /* If needed, display the interface statistics. */
     if (ptr->statistics_valid) {
-	printf("%8llu %6lu %6lu %6lu",
+	printf("%8llu %6lu %6lu %-6lu ",
 	       ptr->stats.rx_packets, ptr->stats.rx_errors,
 	       ptr->stats.rx_dropped, ptr->stats.rx_fifo_errors);
 	printf("%8llu %6lu %6lu %6lu ",
@@ -636,8 +651,8 @@ void ife_print_long(struct interface *ptr)
     int hf;
     int can_compress = 0;
     unsigned long long rx, tx, short_rx, short_tx;
-    char Rext[5]="b";
-    char Text[5]="b";
+    const char *Rext = "B";
+    const char *Text = "B";
 
 #if HAVE_AFIPX
     static struct aftype *ipxtype = NULL;
@@ -670,7 +685,7 @@ void ife_print_long(struct interface *ptr)
     if (hw == NULL)
 	hw = get_hwntype(-1);
 
-    printf(_("%-9.9s Link encap:%s  "), ptr->name, hw->title);
+    printf(_("%-9s Link encap:%s  "), ptr->name, hw->title);
     /* For some hardware types (eg Ash, ATM) we don't print the 
        hardware address if it's null.  */
     if (hw->print != NULL && (! (hw_null_address(hw, ptr->hwaddr) &&
@@ -703,7 +718,7 @@ void ife_print_long(struct interface *ptr)
     /* FIXME: should be integrated into interface.c.   */
 
     if ((f = fopen(_PATH_PROCNET_IFINET6, "r")) != NULL) {
-	while (fscanf(f, "%4s%4s%4s%4s%4s%4s%4s%4s %02x %02x %02x %02x %20s\n",
+	while (fscanf(f, "%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n",
 		      addr6p[0], addr6p[1], addr6p[2], addr6p[3],
 		      addr6p[4], addr6p[5], addr6p[6], addr6p[7],
 		  &if_idx, &plen, &scope, &dad_status, devname) != EOF) {
@@ -843,10 +858,38 @@ void ife_print_long(struct interface *ptr)
 	tx = ptr->stats.tx_bytes;
 	short_rx = rx * 10;  
 	short_tx = tx * 10;
-	if (rx > 1048576) { short_rx /= 1048576;  strcpy(Rext, "Mb"); }
-	else if (rx > 1024) { short_rx /= 1024;  strcpy(Rext, "Kb"); }
-	if (tx > 1048576) { short_tx /= 1048576;  strcpy(Text, "Mb"); }
-	else if (tx > 1024) { short_tx /= 1024;  strcpy(Text, "Kb"); }
+	if (rx > 1000000000000000ull) {
+	    short_rx /= 1000000000000000ull;
+	    Rext = "PB";
+	} else if (rx > 1000000000000ull) {
+	    short_rx /= 1000000000000ull;
+	    Rext = "TB";
+	} else if (rx > 1000000000ull) {
+	    short_rx /= 1000000000ull;
+	    Rext = "GB";
+	} else if (rx > 1000000) {
+	    short_rx /= 1000000;
+	    Rext = "MB";
+	} else if (rx > 1000) {
+	    short_rx /= 1000;
+	    Rext = "KB";
+	}
+	if (tx > 1000000000000000ull) {
+	    short_tx /= 1000000000000000ull;
+	    Text = "PB";
+	} else 	if (tx > 1000000000000ull) {
+	    short_tx /= 1000000000000ull;
+	    Text = "TB";
+	} else if (tx > 1000000000ull) {
+	    short_tx /= 1000000000ull;
+	    Text = "GB";
+	} else if (tx > 1000000) {
+	    short_tx /= 1000000;
+	    Text = "MB";
+	} else if (tx > 1000) {
+	    short_tx /= 1000;
+	    Text = "KB";
+	}
 
 	printf("          ");
 	printf(_("TX packets:%llu errors:%lu dropped:%lu overruns:%lu carrier:%lu\n"),
@@ -867,7 +910,7 @@ void ife_print_long(struct interface *ptr)
     }
 
     if ((ptr->map.irq || ptr->map.mem_start || ptr->map.dma ||
-	 ptr->map.base_addr)) {
+	 ptr->map.base_addr >= 0x100)) {
 	printf("          ");
 	if (ptr->map.irq)
 	    printf(_("Interrupt:%d "), ptr->map.irq);
diff --git a/lib/ipx.c b/lib/ipx.c
index 0e760a3..13d2761 100644
--- a/lib/ipx.c
+++ b/lib/ipx.c
@@ -133,6 +133,9 @@ static int IPX_input(int type, char *bufp, struct sockaddr *sap)
     char *ep;
     int nbo;
 
+    if (!sai)
+    	return (-1);
+    	
     sai->sipx_family = AF_IPX;
     sai->sipx_network = htonl(0);
     sai->sipx_node[0] = sai->sipx_node[1] = sai->sipx_node[2] =
diff --git a/lib/ipx_gr.c b/lib/ipx_gr.c
index 3d7ef1d..96fac80 100644
--- a/lib/ipx_gr.c
+++ b/lib/ipx_gr.c
@@ -38,21 +38,27 @@ int IPX_rprint(int options)
     char net[128], router_net[128];
     char router_node[128];
     int num;
-    FILE *fp = fopen(_PATH_PROCNET_IPX_ROUTE, "r");
+    FILE *fp;
     struct aftype *ap;
     struct sockaddr sa;
 
-    if ((ap = get_afntype(AF_IPX)) == NULL) {
-	EINTERN("lib/ipx_rt.c", "AF_IPX missing");
-	return (-1);
-    }
+    fp = fopen(_PATH_PROCNET_IPX_ROUTE1, "r");
 
     if (!fp) {
-        perror(_PATH_PROCNET_IPX_ROUTE);
-        printf(_("IPX not configured in this system.\n"));
+        fp = fopen(_PATH_PROCNET_IPX_ROUTE2, "r");
+    }
+    
+    if (!fp) {
+        perror(NULL);
+        printf(_("IPX routing not in file %s or %s found.\n"), _PATH_PROCNET_IPX_ROUTE1, _PATH_PROCNET_IPX_ROUTE2);
 	return 1;
     }
 
+    if ((ap = get_afntype(AF_IPX)) == NULL) {
+	EINTERN("lib/ipx_rt.c", "AF_IPX missing");
+	return (-1);
+    }
+
     printf(_("Kernel IPX routing table\n"));	/* xxx */
     printf(_("Destination               Router Net                Router Node\n"));
 
diff --git a/lib/irda.c b/lib/irda.c
index fa147fe..598e6f0 100644
--- a/lib/irda.c
+++ b/lib/irda.c
@@ -1,13 +1,15 @@
 /*********************************************************************
  *                
  * Filename:      irda.c
- * Version:       0.1
- * Description:   A first attempt to make ifconfig understand IrDA
+ * Version:       0.2
+ * Description:   A second attempt to make ifconfig understand IrDA
  * Status:        Experimental.
  * Author:        Dag Brattli <dagb@cs.uit.no>
  * Created at:    Wed Apr 21 09:03:09 1999
  * Modified at:   Wed Apr 21 09:17:05 1999
  * Modified by:   Dag Brattli <dagb@cs.uit.no>
+ * Modified at:   Wed May  1 11:51:44 CEST 2002
+ * Modified by:   Christoph Bartelmus <christoph@bartelmus.de>
  * 
  *     This program is free software; you can redistribute it and/or 
  *     modify it under the terms of the GNU General Public License as 
@@ -59,9 +61,9 @@
  */
 static char *irda_print(unsigned char *ptr)
 {
-    static char buff[8];
+    static char buff[12];
 
-    sprintf(&buff[strlen(buff)], "%02x:%02x:%02x:%02x", ptr[3], ptr[2], 
+    snprintf(buff, 12, "%02x:%02x:%02x:%02x", ptr[3], ptr[2], 
 	    ptr[1], ptr[0]);
 
     return (buff);
diff --git a/lib/net-features.h b/lib/net-features.h
index 0de2730..e52a3c3 100644
--- a/lib/net-features.h
+++ b/lib/net-features.h
@@ -295,6 +295,13 @@ static char *Features =
 "-"
 #endif
 "HDLC/LAPB "
+
+#if HAVE_HWEUI64
+"+"
+#else
+"-"
+#endif
+"EUI64 "
 ;
 
 
diff --git a/lib/nstrcmp.c b/lib/nstrcmp.c
index 8b1ff30..37b85c6 100644
--- a/lib/nstrcmp.c
+++ b/lib/nstrcmp.c
@@ -1,34 +1,157 @@
 /* Copyright 1998 by Andi Kleen. Subject to the GPL. */
-/* $Id: nstrcmp.c,v 1.2 1998/11/15 20:11:38 freitag Exp $ */ 
+/* rewritten by bernd eckenfels because of complicated alias semantic */
+/* $Id: nstrcmp.c,v 1.4 2004/06/03 22:49:17 ecki Exp $ */ 
 #include <ctype.h>
 #include <stdlib.h>
+#include <string.h>
 #include "util.h"
 
-/* like strcmp(), but knows about numbers */
-int nstrcmp(const char *astr, const char *b)
+
+/* return numerical :999 suffix or null. sideeffect: replace ':' with \0 */
+char* cutalias(char* name)
 {
-    const char *a = astr;
-
-    while (*a == *b) {
-	if (*a == '\0')
-	    return 0;
-	a++;
-	b++;
-    }
-    if (isdigit(*a)) {
-	if (!isdigit(*b))
-	    return -1;
-	while (a > astr) {
-	    a--;
-	    if (!isdigit(*a)) {
-		a++;
-		break;
-	    }
-	    if (!isdigit(*b))
-		return -1;
-	    b--;
+	int digit = 0;
+	int pos;
+	
+	for(pos=strlen(name); pos>0; pos--)
+	{
+		if (name[pos-1]==':' && digit)
+		{
+			name[pos-1]='\0';
+			return name+pos;
+		}
+		if (!isdigit(name[pos-1]))
+			break;
+		digit = 1;
+	}
+	return NULL;
+}
+
+
+/* return index of last non digit or -1 if it does not end with digits */
+int rindex_nondigit(char *name)
+{
+	int pos = strlen(name);
+
+	for(pos=strlen(name); pos>0; pos--)
+	{
+		if (!isdigit(name[pos-1]))
+			return pos;
 	}
-	return atoi(a) > atoi(b) ? 1 : -1;
-    }
-    return *a - *b;
+	return 0;
 }
+
+
+/* like strcmp(), but knows about numbers and ':' alias suffix */
+int nstrcmp(const char *ap, const char *bp)
+{
+	char *a = (char*)strdup(ap);
+	char *b = (char*)strdup(bp);
+	char *an, *bn;
+	int av = 0, bv = 0;
+	char *aalias=cutalias(a);
+	char *balias=cutalias(b);
+	int aindex=rindex_nondigit(a);
+	int bindex=rindex_nondigit(b);
+	int complen=(aindex<bindex)?aindex:bindex;
+	int res = strncmp(a, b, complen);
+
+	if (res != 0)
+		{ free(a); free(b); return res; }
+		
+	if (aindex > bindex)
+		{ free(a); free(b); return 1; }
+		
+	if (aindex < bindex)
+		{ free(a); free(b); return -1; }
+		
+	an = a+aindex;
+	bn = b+bindex;
+	
+	av = atoi(an);
+	bv = atoi(bn);
+	
+	if (av < bv)
+		{ free(a); free(b); return -1; }
+		
+	if (av > bv)
+		{ free(a); free(b); return 1; }
+		
+	av = -1;
+	if (aalias != NULL)
+		av = atoi(aalias);
+	
+	bv = -1;
+	if (balias != NULL)
+		bv = atoi(balias);
+	
+	free(a); free(b);
+	
+	if (av < bv)
+		return -1;
+		
+	if (av > bv)
+		return 1;
+		
+	return 0;
+}
+
+
+#ifdef NSTRCMP_TEST
+
+int cs(int s)
+{
+	if (s < 0) return -1;
+	if (s > 0) return 1;
+	return 0;
+}
+
+
+int dotest(char* a, char* b, int exp)
+{
+	int res = nstrcmp(a, b);
+	int err = (cs(res) != cs(exp));
+	printf("nstrcmp(\"%s\", \"%s\")=%d %d %s\n", a, b, res, exp, err?"WRONG":"OK");
+	return err;
+}
+
+int main()
+{
+	int err = 0;
+	
+	err |= dotest("eth1", "eth1", 0);
+	err |= dotest("eth0:1", "eth0:1", 0);
+	err |= dotest("lan", "lan", 0);
+	err |= dotest("100", "100", 0);
+	err |= dotest("", "", 0);
+	err |= dotest(":", ":", 0);
+	err |= dotest("a:b:c", "a:b:c", 0);
+	err |= dotest("a:", "a:", 0);
+	err |= dotest(":a", ":a", 0);
+
+	err |= dotest("a", "aa", -1);	
+	err |= dotest("eth0", "eth1", -1);
+	err |= dotest("eth1", "eth20", -1);
+	err |= dotest("eth20", "eth100", -1);
+	err |= dotest("eth1", "eth13", -1);
+	err |= dotest("eth", "eth2", -1);
+	err |= dotest("eth0:1", "eth0:2", -1);
+	err |= dotest("eth1:10", "eth13:10", -1);
+	err |= dotest("eth1:1", "eth1:13", -1);
+	err |= dotest("a", "a:", -1);
+	
+	err |= dotest("aa", "a", 1);
+	err |= dotest("eth2", "eth1", 1);
+	err |= dotest("eth13", "eth1", 1);	
+	err |= dotest("eth2", "eth", 1);
+	err |= dotest("eth2:10", "eth2:1", 1);
+	err |= dotest("eth2:5", "eth2:4", 1);
+	err |= dotest("eth3:2", "eth2:3", 1);
+	err |= dotest("eth13:1", "eth1:0", 1);
+	err |= dotest("a:", "a", 1);
+	err |= dotest("a1b12", "a1b2", 1);
+
+	return err;
+}
+
+#endif
diff --git a/lib/pathnames.h b/lib/pathnames.h
index 1f7fefb..0764ce9 100644
--- a/lib/pathnames.h
+++ b/lib/pathnames.h
@@ -1,4 +1,3 @@
-
 /*
  * lib/pathnames.h    This file contains the definitions of the path 
  *                      names used by the NET-LIB.
@@ -29,8 +28,10 @@
 #define _PATH_PROCNET_NR_NODES		"/proc/net/nr_nodes"
 #define _PATH_PROCNET_ARP		"/proc/net/arp"
 #define _PATH_PROCNET_AX25		"/proc/net/ax25"
-#define _PATH_PROCNET_IPX		"/proc/net/ipx"
-#define _PATH_PROCNET_IPX_ROUTE		"/proc/net/ipx_route"
+#define _PATH_PROCNET_IPX_SOCKET1	"/proc/net/ipx/socket"
+#define _PATH_PROCNET_IPX_SOCKET2	"/proc/net/ipx"
+#define _PATH_PROCNET_IPX_ROUTE1	"/proc/net/ipx/route"
+#define _PATH_PROCNET_IPX_ROUTE2	"/proc/net/ipx_route"
 #define _PATH_PROCNET_ATALK		"/proc/net/appletalk"
 #define _PATH_PROCNET_IP_BLK		"/proc/net/ip_block"
 #define _PATH_PROCNET_IP_FWD		"/proc/net/ip_forward"
@@ -45,6 +46,7 @@
 #define _PATH_PROCNET_X25              "/proc/net/x25"
 #define _PATH_PROCNET_X25_ROUTE                "/proc/net/x25_routes"
 #define _PATH_PROCNET_DEV_MCAST		"/proc/net/dev_mcast"
+#define _PATH_PROCNET_ATALK_ROUTE	"/proc/net/atalk_route"
 
 /* pathname for the netlink device */
 #define _PATH_DEV_ROUTE	"/dev/route"
diff --git a/lib/proc.c b/lib/proc.c
index bf34dbe..9cd4eeb 100644
--- a/lib/proc.c
+++ b/lib/proc.c
@@ -1,11 +1,12 @@
 /* Tolerant /proc file parser. Copyright 1998 Andi Kleen */
-/* $Id: proc.c,v 1.4 1999/01/05 20:54:00 philip Exp $ */ 
+/* $Id: proc.c,v 1.5 2007/12/01 18:44:57 ecki Exp $ */ 
 /* Fixme: cannot currently cope with removed fields */ 
 
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <ctype.h>
+#include <unistd.h>
 
 /* Caller must free return string. */
 
@@ -72,3 +73,22 @@ int proc_guess_fmt(char *name, FILE *fh, ...)
     va_end(ap);
     return flag;
 }
+
+
+FILE *proc_fopen(const char *name)
+{
+    static char *buffer;
+    static size_t pagesz;
+    FILE *fd = fopen(name, "r");
+
+    if (fd == NULL)
+      return NULL;
+      
+    if (!buffer) {
+      pagesz = getpagesize();
+      buffer = malloc(pagesz);
+    }
+    
+    setvbuf(fd, buffer, _IOFBF, pagesz);
+    return fd;
+}
diff --git a/lib/proc.h b/lib/proc.h
index 91f803c..0f4ed93 100644
--- a/lib/proc.h
+++ b/lib/proc.h
@@ -1,5 +1,7 @@
-
-
-/* Generate a suitable scanf format for a column title line */
+/* 
+ * prototypes for proc.c
+ */
 char *proc_gen_fmt(char *name, int more, FILE * fh,...);
 int   proc_guess_fmt(char *name, FILE* fh,...);
+FILE *proc_fopen(const char *name);
+
diff --git a/lib/tr.c b/lib/tr.c
index 8d86aa7..c75f256 100644
--- a/lib/tr.c
+++ b/lib/tr.c
@@ -2,7 +2,7 @@
  * lib/tr.c   This file contains an implementation of the "Tokenring"
  *              support functions.
  *
- * Version:     $Id: tr.c,v 1.8 2000/02/02 08:56:30 freitag Exp $
+ * Version:     $Id: tr.c,v 1.9 2005/05/16 03:15:12 ecki Exp $
  *
  * Author:      Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
  *              Copyright 1993 MicroWalt Corporation
@@ -30,8 +30,14 @@
 #include "net-support.h"
 #include "pathnames.h"
 #include "intl.h"
+#include "util.h"
 
+
+/* actual definition at the end of file */
 extern struct hwtype tr_hwtype;
+#ifdef ARPHRD_IEEE802_TR
+extern struct hwtype tr_hwtype1;
+#endif
 
 static char *pr_tr(unsigned char *ptr)
 {
@@ -42,7 +48,7 @@ static char *pr_tr(unsigned char *ptr)
 	     (ptr[3] & 0377), (ptr[4] & 0377), (ptr[5] & 0377)
 	);
     return (buff);
-}
+      }
 
 
 static int in_tr(char *bufp, struct sockaddr *sap)
@@ -51,7 +57,17 @@ static int in_tr(char *bufp, struct sockaddr *sap)
     char c, *orig;
     int i, val;
 
+#ifdef ARPHRD_IEEE802_TR
+    if (kernel_version() < KRELEASE(2,3,30)) { 
+        sap->sa_family = tr_hwtype.type;
+    } else { 
+        sap->sa_family = tr_hwtype1.type;
+    } 	
+#else
     sap->sa_family = tr_hwtype.type;
+    #warning "Limited functionality, no support for ARPHRD_IEEE802_TR (old kernel headers?)"
+#endif
+
     ptr = sap->sa_data;
 
     i = 0;
diff --git a/lib/util-ank.c b/lib/util-ank.c
index 43a7f1c..b077f35 100644
--- a/lib/util-ank.c
+++ b/lib/util-ank.c
@@ -293,7 +293,7 @@ int inet_addr_match(inet_prefix *a, inet_prefix *b, int bits)
 	return 0;
 }
 
-const char *format_host(int af, void *addr, __u8 *abuf, int alen)
+const char *format_host(int af, void *addr, char *abuf, int alen)
 {
 #ifdef RESOLVE_HOSTNAMES
 	if (resolve_hosts) {
diff --git a/lib/util.h b/lib/util.h
index 6acb158..b71a4de 100644
--- a/lib/util.h
+++ b/lib/util.h
@@ -14,3 +14,6 @@ int nstrcmp(const char *, const char *);
 
 char *safe_strncpy(char *dst, const char *src, size_t size); 
 
+
+#define netmin(a,b) ((a)<(b) ? (a) : (b))
+#define netmax(a,b) ((a)>(b) ? (a) : (b))
diff --git a/lib/x25_sr.c b/lib/x25_sr.c
index 8637c98..3d65759 100644
--- a/lib/x25_sr.c
+++ b/lib/x25_sr.c
@@ -67,7 +67,7 @@ static int X25_setroute(int action, int options, char **args)
   strcpy(target, *args++);
 
   /* Clean out the x25_route_struct structure. */
-  memset((char *) &rt, 0, sizeof(struct x25_route_struct));
+  memset((char *) &rt, 0, sizeof(rt));
 
 
   if ((sigdigits = x25_aftype.input(0, target, (struct sockaddr *)&sx25)) < 0) {
@@ -76,8 +76,8 @@ static int X25_setroute(int action, int options, char **args)
   }
   rt.sigdigits=sigdigits;
 
-  /* x25_route_struct.address isn't type struct sockaddr_x25, Why? */
-  memcpy(&rt.address, &sx25.sx25_addr, sizeof(x25_address));
+  /* this works with 2.4 and 2.6 headers struct x25_address vs. typedef */
+  memcpy(&rt.address, &sx25.sx25_addr, sizeof(sx25.sx25_addr));
 
   while (*args) {
 	if (!strcmp(*args,"device") || !strcmp(*args,"dev")) {
diff --git a/man/de_DE/arp.8 b/man/de_DE/arp.8
index debd879..9adece7 100644
--- a/man/de_DE/arp.8
+++ b/man/de_DE/arp.8
@@ -1,12 +1,12 @@
-.TH ARP 8 "6. M\(:arz 1999" "net-tools" "Handbuch f\(:ur Linuxprogrammierer"
+.TH ARP 8 "6. M\(:arz 1999" "net\-tools" "Handbuch f\(:ur Linuxprogrammierer"
 .SH NAME
 arp \- Manipulation des ARP-Caches
 .SH SYNOPSIS
 .B arp 
 .RB [ \-vn ] 
 .RB [ "\-H Typ" ] 
-.RB [ "-i Schnittstelle" ] 
-.B -a 
+.RB [ "\-i Schnittstelle" ] 
+.B \-a 
 .RB [ Rechnername ]
 .PP
 .B arp 
@@ -19,14 +19,14 @@ arp \- Manipulation des ARP-Caches
 .RB [ \-v ] 
 .RB [ "\-H Typ" ] 
 .RB [ "\-i Schnittstelle" ] 
-.B -s Rechnername hw_adr
+.B \-s Rechnername hw_adr
 .RB [ temp ] 
 .PP
 .B arp 
 .RB [ \-v ] 
 .RB [ "\-H Typ" ] 
 .RB [ "\-i Interface" ] 
-.B -s Rechnername hw_adr
+.B \-s Rechnername hw_adr
 .RB [ "netmask nm" ] 
 .B pub
 .PP
@@ -34,15 +34,15 @@ arp \- Manipulation des ARP-Caches
 .RB [ \-v ] 
 .RB [ "\-H Typ" ] 
 .RB [ "\-i Schnittstelle" ] 
-.B -Ds Rechnername ifa
+.B \-Ds Rechnername ifa
 .RB [ "netmask nm" ] 
 .B pub
 .PP
 .B arp 
 .RB [ \-vnD ]
 .RB [ "\-H Typ" ] 
-.RB [ "-i Schnittstelle" ]
-.B -f [Dateiname]
+.RB [ "\-i Schnittstelle" ]
+.B \-f [Dateiname]
 
 .SH BESCHREIBUNG
 .B Arp
@@ -61,7 +61,7 @@ Ausf\(:uhrlichere Ausgaben.
 macht numerische Adressausgaben anstatt zu versuche, den symbolischen Rechner-,
 Port- oder Benutzernamen zu ermitteln.
 .TP
-.B "\-H type, \-\-hw-type type"
+.B "\-H type, \-\-hw\-type type"
 Beim Setzen oder Auslesen des ARP-Caches schr\(:ankt diese Option
 ein, auf welcher Klasse von Eintr\(:agen 
 .B arp
@@ -86,7 +86,7 @@ Argument verwendet, so werden alle Eintr\(:age aufgelistet.
 Alle Eintr\(:age f\(:ur den angegebenen Host entfernen.  Dies kann z.B.
 benutzt werden, wenn ein System angehalten wird.
 .TP
-.B "\-D, \-\-use-device"
+.B "\-D, \-\-use\-device"
 Die Hardwareadresse der Netzwerksschnittstelle
 .B ifa
 verwenden.
@@ -180,6 +180,6 @@ Flagge.
 ethers(5), rarp(8), route(8), ifconfig(8), netstat(8)
 .SH AUTOREN
 Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org> mit vielen Verbesserungen vom
-Verwalter der Net-Tools Bernd Eckenfels <net-tools@lina.inka.de>.
+Verwalter der Net-Tools Bernd Eckenfels <net\-tools@lina.inka.de>.
 .SH \(:Ubersetzung
 Ralf B\(:achle <ralf@gnu.org>
diff --git a/man/de_DE/hostname.1 b/man/de_DE/hostname.1
index ce0cadb..2122018 100644
--- a/man/de_DE/hostname.1
+++ b/man/de_DE/hostname.1
@@ -3,7 +3,7 @@
 .\"
 .\" German translation by Ralf Baechle (ralf@gnu.org)
 .\"
-.TH HOSTNAME 1 "6. M\(:arz 1999" "net-tools" "Handbuch f\(:ur Linuxprogrammierer"
+.TH HOSTNAME 1 "6. M\(:arz 1999" "net\-tools" "Handbuch f\(:ur Linuxprogrammierer"
 
 .SH NAME
 hostname \- den Rechnernamen anzeigen oder setzen.
@@ -28,7 +28,7 @@ nodename \- den DECnet-Knotennamen anzeigen oder setzen
 .RB [ \-f ]
 .RB [ \-\-fqdn ]
 .RB [ \-i ]
-.RB [ \-\-ip-address ]
+.RB [ \-\-ip\-address ]
 .RB [ \-\-long ]
 .RB [ \-s ]
 .RB [ \-\-short ]
@@ -195,7 +195,7 @@ ge\(:andert werden.
 .I "\-h, \-\-help"
 Kurzanleitung ausdrucken und beenden.
 .TP
-.I "\-i, \-\-ip-address"
+.I "\-i, \-\-ip\-address"
 Die IP-Adresse(n) des Rechners anzeigen und beenden.
 .TP
 .I "\-n, \-\-node"
@@ -220,9 +220,9 @@ Option gegeben wird, dann kann Root auch eine neue NIS-Domain setzen.
 .SH DATEIEN
 .B /etc/hosts
 .SH AUTOREN
-Peter Tobias, <tobias@et-inf.fho-emden.de>
+Peter Tobias, <tobias@et\-inf.fho\-emden.de>
 .br
-Bernd Eckenfels, <net-tools@lina.inka.de> (NIS and manpage).
+Bernd Eckenfels, <net\-tools@lina.inka.de> (NIS and manpage).
 .br
 Steve Whitehouse, <SteveW@ACM.org> (DECnet support and manpage).
 .SH \(:Ubersetzung
diff --git a/man/de_DE/ifconfig.8 b/man/de_DE/ifconfig.8
index aa2a4a0..c77805c 100644
--- a/man/de_DE/ifconfig.8
+++ b/man/de_DE/ifconfig.8
@@ -1,4 +1,4 @@
-.TH IFCONFIG 8 "6. M\(:arz 1999" "net-tools" "Handbuch f\(:ur Linuxprogrammierer"
+.TH IFCONFIG 8 "2007-12-02" "net\-tools" "Handbuch f\(:ur Linuxprogrammierer"
 .SH NAME
 ifconfig \- Konfiguration einer Netzwerkskarte
 .SH SYNOPSIS
@@ -19,7 +19,7 @@ Wird ein einzelne
 .BR Schnittstelle nargument
 angegeben, so zeigt es nur den Zustand der angegebenen Netzwerksschnittstelle
 an.  Wird ein einzelne
-.B -a
+.B \-a
 Option angegeben, zeigt es den Zustand aller Schnittstellen an, selbst wenn
 diese inaktiviert sind.  Ansonsten konfiguriert
 .B ifconfig
@@ -130,13 +130,13 @@ sind
 kann benutzt werden, damit der Treiber automatischen den Typ des Mediums
 erkennt.  Wiederum unterst\(:utzen dies nicht alle Treiber.
 .TP
-.B "[-]broadcast [Adr]"
+.B "[\-]broadcast [Adr]"
 Wird das Adressargument gegeben, so wird die Protokolladresse f\(:ur Broadcast
 f\(:ur diese Schnittstelle gesetzt.  Ansonsten wird die
 .B IFF_BROADCAST
 Flagge f\(:ur diese Schnittstelle gesetzt bzw. gel\(:oscht.
 .TP
-.B "[-]pointopoint [Adr]"
+.B "[\-]pointopoint [Adr]"
 Dieses Schl\(:usselwort aktiviert den
 .B Punkt-zu-Punkt
 Modus einer Schnittstelle.  Das bedeutet, da\(ss eine Verbindung zwischen zwei
@@ -193,7 +193,7 @@ Kommando gemacht werden.
 W\(:ahrend AppleTalk DDP und IPX Adressen angezeigt werden, k\(:onnen sie mit
 diesem Kommando nicht ge\(:andert werden.
 .SH SIEHE AUCH
-route(8), netstat(8), arp(8), rarp(8), ipchains(8)
+route(8), netstat(8), arp(8), rarp(8), ipchains(8), iptables(8), ifup(8), interfaces(5).
 .SH AUTOREN
 Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 .br
diff --git a/man/de_DE/netstat.8 b/man/de_DE/netstat.8
index f59aec0..9b7ddf8 100644
--- a/man/de_DE/netstat.8
+++ b/man/de_DE/netstat.8
@@ -9,7 +9,7 @@
 .\" Modified: Tuan Hoang tuan@optimus.mitre.org 
 .\"
 .\"
-.TH NETSTAT 8 "6. M\(:arz 1999" "net-tools" "Handbuch f\(:ur Linuxprogrammierer"
+.TH NETSTAT 8 "2007-12-02" "net\-tools" "Handbuch f\(:ur Linuxprogrammierer"
 
 .SH NAME
 netstat \- Anzeige von Netzwerksverbindungen, Routentabellen, Schnittstellenstatistiken, maskierten Verbindungen, Netlink-Nachrichten und Mitgliedschaft in Multicastgruppen
@@ -44,7 +44,6 @@ netstat \- Anzeige von Netzwerksverbindungen, Routentabellen, Schnittstellenstat
 .B netstat
 .RB [ \-veenpac ]
 .RB { \-\-interfaces | \-i }
-.RI [ Schnittstelle ]
 
 .PP
 
@@ -68,6 +67,8 @@ netstat \- Anzeige von Netzwerksverbindungen, Routentabellen, Schnittstellenstat
 .SH BESCHREIBUNG
 .B Netstat
 zeigt Informationen des Linux Netzwerkssystems an.
+.PP
+.B Bitte beachten Sie, dass der Inhalt der deutschen man-page nicht vollst\(:andig ist, im Moment.
 
 .SS "(no option)"
 Ohne Optionen zeigt
@@ -75,17 +76,17 @@ Ohne Optionen zeigt
 den Zustand von offenen Sockets an.  Wird keine Adressfamilie angegeben, dann
 werden die offenen Sockets aller konfigurierten Adressfamilien gedruckt.
 Die Option
-.B -e
+.B \-e
 gibt zus\(:atzliche Informationen aus (User ID).  Mit der Option
-.B -v
+.B \-v
 gibt
 .B netstat
 zus\(:atzlich Fehlermeldungen \(:uber von Kernel nicht unterst\(:utzte
 Adressfamilien aus.  Die Option
-.B -p
+.B \-p
 gibt zus\(:atzlich die PID und den Namen des Programms, das den Socket
 ge\(:offnet hat, aus.
-.B -a
+.B \-a
 druckt alle Sockets einschlie\(sslich der auf Verbinungen wartenden
 Serversockets aus.  Die Adressfamilie
 .B inet
@@ -95,29 +96,28 @@ zeigt RAW, UDP und TCP Sockets an.
 Die
 .BR \-r ", " \-\-route
 Option gibt die Routentabellen des Kernels im gleichen Format wie
-.B "route -e" 
+.B "route \-e" 
 aus.
-.B "netstat -er" 
+.B "netstat \-er" 
 benutzt das Ausgabeformat von
 .BR route .
 Wegen Details siehe
 .BR route (8).
 
-.SS "\-i, \-\-interface \fISchnittstelle\fI"
+.SS "\-i, \-\-interfaces"
 Wird die
-.BR -i ", " --interfaces
-Option verwendet,  so wird eine Tabelle aller (oder der angegebenen
-.IR Schnittstellen ) 
+.BR \-i ", " \-\-interfaces
+Option verwendet,  so wird eine Tabelle aller Schnittstellen
 ausgedruckt.  Die Ausgabe ist im Format von
-.B "ifconfig -e"
+.B "ifconfig \-e"
 und wird in
 .BR ifconfig (8)
 beschrieben.
-.B "netstat -ei" 
-druckt eine Tabelle oder einen Eintrag f\(:ur einen einzelnes Interface wie
+.B "netstat \-ei" 
+druckt eine Tabelle f\(:ur Interfaces wie
 .BR ifconfig .
 Die
-.B -a
+.B \-a
 Option schlie\(sst Schnittstellen, die gar nicht konfiguriert sind in die
 Ausgabe ein, d.h. die die
 .BR U = UP
@@ -126,7 +126,7 @@ Flagge nicht gesetzt haben).
 .SS "\-M, \-\-masquerade"
 
 Eine Liste aller maskierten Sitzungen wird dargestellt.  Der
-.B -e 
+.B \-e 
 Schalter schlie\(sst zus\(:atzlich Information \(:uber Sequenznummern und
 Deltas, die durch das Umschreiben von FTP-Sitzungen (PORT Kommando) verursacht
 werden.  Maskieren wird dazu verwendet um Maschinen mit inoffiziellen
@@ -182,7 +182,7 @@ Dies hat den gleichen Effekt wie die Langoptionen
 und
 .BR \-\-ddp.
 
-.SS "\-c, \-\-continous"
+.SS "\-c, \-\-continuous"
 Mit dieser Option wiederholt
 .B netstat
 im Sekundenabstand die Ausgabe, bis es abgebrochen wird.
@@ -196,24 +196,24 @@ im Sekundenabstand die Ausgabe, bis es abgebrochen wird.
 .SS "Proto" 
 Das von Socket verwendete Protokoll (TCP, UDP, RAW).
 
-.SS "Recv-Q"
+.SS "Recv\-Q"
 Die Anzahl von Bytes, die noch nicht von der Anwendung vom Socket abgeholt
 wurden.
 
-.SS "Send-Q"
+.SS "Send\-Q"
 Die Anzahl von Bytes, die von der Gegenseite noch nicht best\(:atigt wurde.
 
 .SS "Lokale Adresse" 
 Die lokale Adresse (lokaler Rechnername) und Portnummer des Sockets.  Au\(sser
 bei Verwendung der
-.B -n
+.B \-n
 Option wird die Socketadresse nach dem kanonischen Rechnernamen und die
 Portnummer in den zugeh\(:origen Dienstenamen aufgel\(sst.
 
 .SS "Gegenadresse"
 Die Adresse und Portnummer der Gegenseite des Sockets.  Wie bei lokalen
 Adressen schaltet der
-.B -n
+.B \-n
 Schalter die Umwandlung von Rechneradresse und Portnummer ab.
 
 .SS "State"
@@ -267,7 +267,7 @@ Der Socket wartet auf eingehende Verbindungen.  Diese Sockets werden nur
 angezeit, wenn die
 The socket is listening for incoming connections. Those sockets are only
 displayed if the
-.BR -a , --listening
+.BR \-a , \-\-listening
 Option gegeben wird.
 .TP
 .I
@@ -285,7 +285,7 @@ Der Name oder die Benutzer-ID des Eigent\(:umers des Sockets.
 .SS "PID/Program name"
 Durch einen Schr\(:agstrich abgetrenntes Paar von Prozess-ID und Programmname
 des Programms, das diesen Socket besitzt.  Die Option
-.B -p
+.B \-p
 schaltet die Anzeige dieser Spalte ein.  Es werden
 .B root
 Privilegien ben\(:otigt um die n\(:otigen Daten zu erhalten.  F\(:ur IPX
@@ -359,7 +359,7 @@ Der Socket ist unbenutzt
 H\(:Ort
 Der Socket lauscht nach Verbindungsanfragen.  Diese Sockets werden nur
 angezeigt, wenn die
-.BR -a , --listening
+.BR \-a , \-\-listening
 Option gesetzt ist.
 .TP
 .I
@@ -411,7 +411,7 @@ werden.)
 
 .PP
 .SH BEMERKUNGEN
-Seit der Kern Version 2.2 zeigt netstat -i keine Schnittstellenstatistiken
+Seit der Kern Version 2.2 zeigt netstat \-i keine Schnittstellenstatistiken
 von Schnittstellenaliasen mehr an.  Um Statistiken per Schnittstelle zur
 erhalten, m\(:ussen jetzt mit dem
 .BR ipchains(8) 
@@ -489,14 +489,14 @@ so kann unsinnige Information ausgegeben werden.  Dies ist jedoch
 unwahrscheinlich.
 .br
 Die
-.B netstat -i
+.B netstat \-i
 die beschrieben wird sollte nach einigem S\(:aubern der BETA-Version des
 Codes des Net-Tools Packets funktionieren.
 
 .PP
 .SH AUTOREN
 Die Benutzerschnittstelle wurde von Fred Baumgarten
-<dc6iq@insu1.etec.uni-karlsruhe.de> geschrieben, die Manpage zum gr\(:o\(ssten
+<dc6iq@insu1.etec.uni\-karlsruhe.de> geschrieben, die Manpage zum gr\(:o\(ssten
 Teil von Matt Welsh <mdw@tc.cornell.edu>.  Sie wurde von Alan Cox
 <Alan.Cox@linux.org> aktualisiert, ben\(:otigt aber weitere Arbeit.
 .br
diff --git a/man/de_DE/plipconfig.8 b/man/de_DE/plipconfig.8
index 85709d8..b8e76d9 100644
--- a/man/de_DE/plipconfig.8
+++ b/man/de_DE/plipconfig.8
@@ -1,4 +1,4 @@
-.TH PLIPCONFIG 8 "6. M\(:arz 1999" "net-tools" "Handbuch f\(:ur Linuxprogrammierer"
+.TH PLIPCONFIG 8 "6. M\(:arz 1999" "net\-tools" "Handbuch f\(:ur Linuxprogrammierer"
 .SH NAME
 plipconfig \- Einstellung von PLIP Schnittstellen-Parametern
 .SH SYNOPSIS
diff --git a/man/de_DE/rarp.8 b/man/de_DE/rarp.8
index 30d9e78..0d6defd 100644
--- a/man/de_DE/rarp.8
+++ b/man/de_DE/rarp.8
@@ -1,14 +1,14 @@
-.TH RARP 8 "6. M\(:arz 1999" "net-tools" "Handbuch f\(:ur Linuxprogrammierer"
+.TH RARP 8 "6. M\(:arz 1999" "net\-tools" "Handbuch f\(:ur Linuxprogrammierer"
 .SH NAME
 rarp \- Manipulation des RARP-Caches
 .SH SYNOPSIS
-.B "rarp [-V] [--version] [-h] [--help]"
+.B "rarp [\-V] [\-\-version] [\-h] [\-\-help]"
 .br
-.B "rarp -a"
+.B "rarp \-a"
 .br
-.B "rarp [-v] -d Rechnername ..."
+.B "rarp [\-v] \-d Rechnername ..."
 .br
-.B "rarp [-v] [-t type] -s Rechnername hw_addr"
+.B "rarp [\-v] [\-t type] \-s Rechnername hw_addr"
 .SH BESCHREIBUNG
 .B Rarp
 kann die RARP-Tabelle des Kernels auf verschiedene Arten manipulieren.  Die
diff --git a/man/de_DE/route.8 b/man/de_DE/route.8
index a28c9d1..8d30f18 100644
--- a/man/de_DE/route.8
+++ b/man/de_DE/route.8
@@ -1,4 +1,4 @@
-.TH ROUTE 8 "6. M\(:arz 1999" "net-tools" "Handbuch f\(:ur Linuxprogrammierer"
+.TH ROUTE 8 "2007-12-02" "net\-tools" "Handbuch f\(:ur Linuxprogrammierer"
 .SH NAME
 route \- Anzeigen der IP-Routen-Tabelle
 .SH SYNOPSIS
@@ -51,11 +51,11 @@ Schnittstelle]
 .RB [ \-V ] 
 .RB [ \-\-version ]
 .RB [ \-h ]
-.RB [ \--help ]
+.RB [ \-\-help ]
 .SH BESCHREIBUNG
 .B Route
 wird zum \(:Andern der IP-Routing-Tabelle der Kernels verwendet.  Seine
-prim\(:are Verwendung ist statische Routen f\*:ur bestimmte Rechner oder
+prim\(:are Verwendung ist statische Routen f\(:ur bestimmte Rechner oder
 Netzwerke \(:uber eine Schnittstelle einzutragen, nachdem diese mit dem
 Programm
 .BR ifconfig (8)
@@ -92,13 +92,13 @@ Das
 ist ein Netzwerk.
 
 .TP
-.B -host
+.B \-host
 daS
 .B Ziel
 ist ein Rechner
 
 .TP 
-.B -F
+.B \-F
 Zeit die FIB Routentabelle des Kerns an.  Das Ausgabeformat kann mit den
 Optionen
 .B \-e
@@ -107,7 +107,7 @@ and
 ge\(:andert werden.
 
 .TP 
-.B -C
+.B \-C
 zeigt den Routencache des Kernels an.
 
 .TP
@@ -120,8 +120,8 @@ f\(:ugt eine Route zu.
 
 .TP
 .B Ziel
-Das Zielnetzwerk oder -System.  Die Angabe von sowohl IP-Adressen in Form
-von dezimalen durch Punkt getrennten Quadrupeln als auch Rechner- und
+Das Zielnetzwerk oder \(hySystem.  Die Angabe von sowohl IP-Adressen in Form
+von dezimalen durch Punkt getrennten Quadrupeln als auch Rechner\(hy und
 Netznamen ist zul\(:assig.
 
 .TP
@@ -130,7 +130,7 @@ Netznamen ist zul\(:assig.
 
 .TP
 .B gw Router
-Alle IP-Pakete f\(:ur das Zielnetzwerk / -System werden zum angegebenen
+Alle IP-Pakete f\(:ur das Zielnetzwerk / \(hySystem werden zum angegebenen
 Router weitergeleitet.
 
 .B ANMERKUNG:
@@ -202,7 +202,7 @@ der Optionen (metric, netmask, gw und dev), die die Route ver\(:andern, egal.
 
 .SH BEISPIELE
 .TP
-.B route add -net 127.0.0.0
+.B route add \-net 127.0.0.0
 erzeugt die normale Loopbackroute mit der Netzmaske 255.0.0.0 (Netzwerk Klasse
 A, ermittelt aus der Zieladresse) und assoziert sie mit der Schnittstelle lo
 unter der Annahme, da\(ss dieses Ger\(:at vorher mit
@@ -210,18 +210,18 @@ unter der Annahme, da\(ss dieses Ger\(:at vorher mit
 konfiguriert wurde. 
 
 .TP 
-.B route add -net 192.56.76.0 netmask 255.255.255.0 dev eth0
+.B route add \-net 192.56.76.0 netmask 255.255.255.0 dev eth0
 Legt eine Route zum Netzwerk 192.56.76.x \(:uber eth0 an.  Die Angabe der
 Klasse C Netzmaske ist in diesem Fall nicht n\(:otig, 192.* Klasse C
 IP-Adressen sind.  Das Wort dev darf in diesem Fall ausgelassen werden.
 
 .TP
-.B route add default gw mango-gw
+.B route add default gw mango\-gw
 legt eine Standardroute, d.h. eine Route die verwendet wird, wenn keine andere
-Route passt, an.  Alle Pakete \(:uber diese Route werden \(:uber mango-gw
+Route passt, an.  Alle Pakete \(:uber diese Route werden \(:uber mango\-gw
 weitergeleitet.  Die Schnittstelle, die tats\(:achlich f\(:ur diese Route
-verwendet wird, h\(:angt davon ab, wie mango-gw erreicht werden kann.  Zuvor
-mu\(ss mango-gw bereits \(:uber eine andere Route erreicht werden k\(:onnen.
+verwendet wird, h\(:angt davon ab, wie mango\-gw erreicht werden kann.  Zuvor
+mu\(ss mango\-gw bereits \(:uber eine andere Route erreicht werden k\(:onnen.
 
 .TP
 .B route add ipx4 sl0
@@ -229,7 +229,7 @@ Legt eine Route zum Rechner ipx4 \(:uber die SLIP-Schnittstelle an.  Dabei
 wird angenommen da\(ss ipx4 der SLIP-Rechner auf der Gegenseite ist.
 
 .TP
-.B route add -net 192.57.66.0 netmask 255.255.255.0 gw ipx4
+.B route add \-net 192.57.66.0 netmask 255.255.255.0 gw ipx4
 Dieses Kommando sorgt daf\(:ur, dass das Netz 192.57.66.x \(:uber die
 obige Route \(:uber die SLIP-Schnittstelle weitergeleitet wird.
 
@@ -250,7 +250,7 @@ Dies installiert eine zur\(:uckweisende Route f\(:ur das private Netzwerk
 Die Ausgabe der Kernelroutentabelle besteht aus folgenden Spalten
 .TP
 .B Ziel
-Das Zielnetzwerk oder -System.
+Das Zielnetzwerk oder \(hySystem.
 .TP
 .B Router
 Die Adresse des weiterleitenden Routers oder "*", wenn keine gesetzt ist.
@@ -296,10 +296,10 @@ von Routend\(:amonen ben\(:otigt werden.
 Anzahl der Referenzen auf diese Route.  Wird vom Linux Kern nicht benutzt.
 .TP
 .B Benutzer
-Zahl der Suchvorg\(:ange nach dieser Route.  Abh\(:angig von -F und -C
-werden entweder fehlgeschlagene Suchen im Cache (-F) oder Cache-Treffer (-C)
-Count of lookups for the route.  Depending on the use of -F and -C this will
-be either route cache misses (-F) or hits (-C).
+Zahl der Suchvorg\(:ange nach dieser Route.  Abh\(:angig von \-F und \-C
+werden entweder fehlgeschlagene Suchen im Cache (\-F) oder Cache-Treffer (\-C)
+Count of lookups for the route.  Depending on the use of \-F and \-C this will
+be either route cache misses (\-F) or hits (\-C).
 .TP
 .B Schnittstelle
 Schnittstelle auf die Pakete f\(:ur diese Route geleitet werden.
@@ -345,6 +345,6 @@ zugef\(:ugt.  Bernd Eckenfels hat schlie\(sslich die Unterst\(:utzung f\(:ur
 irtt beigesteuert und den Code mit dem von Netstat vereinigt.
 .SH AUTOREN
 .B Route
-wird zur Zeit von Phil Blundel (Philip.Blundell@pobox.com) gewartet.
+wird zur Zeit von Phil Blundel <Philip.Blundell@pobox.com> und Bernd Eckenfels <net-tools@lina.inka.de> gewartet.
 .SH \(:Ubersetzung
 Ralf B\(:achle <ralf@gnu.org>
diff --git a/man/de_DE/slattach.8 b/man/de_DE/slattach.8
index 603281c..4084dfe 100644
--- a/man/de_DE/slattach.8
+++ b/man/de_DE/slattach.8
@@ -1,8 +1,8 @@
-.TH SLATTACH 8 "6. M\(:arz 1999" "net-tools" "slattach"
+.TH SLATTACH 8 "6. M\(:arz 1999" "net\-tools" "slattach"
 .SH NAME
 slattach \- Anbindung einer Netzwerksschnittstelle an eine serielle Verbindung
 .SH SYNOPSIS
-.B "slattach [-dehlLmnqv] [-c Kommando] [-p Protokoll] [-s Geschwindigkeit]
+.B "slattach [\-dehlLmnqv] [\-c Kommando] [\-p Protokoll] [\-s Geschwindigkeit]
 [Terminal]"
 .br
 .SH BESCHREIBUNG
@@ -12,46 +12,46 @@ Reihe von m\(:oglichen Netzwerksmodi umzuschalten.  Dadurch wird es
 m\(:oglich, es zur Verbindung mit anderen Computern zu verwenden.
 .SH OPTIONEN
 .TP
-.B "[-c Kommando]"
+.B "[\-c Kommando]"
 Den Befehl
 .B Kommando
 beim Auflegen der Verbindung ausf\(:uhren.  Die kann benutzt werden um
 Skripte laufen zu lassen oder eine Verbindung nach Abbruch wiederaufzubauen.
 .TP
-.B "[-d]"
+.B "[\-d]"
 Zus\(:atzliche Ausgaben zur Fehlersuche einschalten.  N\(:utzlich, wenn
 eine Konfiguration nicht arbeitet.
 .TP
-.B "[-h]"
+.B "[\-h]"
 Beenden, wenn der Tr\(:ager verloren geht.  Dies funktioniert sowohl auf
 /dev/tty als auch auf /dev/cua Ger\(:aten dadurch, da\(ss der Tr\(:ager
 alle 15 Sekunden \(:uberpr\(:uft wird.
-.B "[-v]"
+.B "[\-v]"
 Ausf\(:uhrliche Ausgaben.  Die ist n\(:utzlich in Shellskripten.
 .TP
-.B "[-q]"
+.B "[\-q]"
 Schaltet alle Ausgaben aus.
 .TP
-.B "[-l]"
+.B "[\-l]"
 Erzeugt eine Sperrdatei in /var/lock \(:ahnlich wie UUCP.
 .TP
-.B "[-n]"
+.B "[\-n]"
 Equivalent mit dem
 .B mesg n
 Befehl.
 .TP
-.B "[-m]"
+.B "[\-m]"
 Versetzt \fBnot\fP die Verbindung in den 8-bit raw-Modus.
 .TP
-.B "[-e]"
+.B "[\-e]"
 Beenden sofort nach der Initialisierung des Ger\(:ats anstelle darauf zu
 warten, da\(ss die Leitung aufgelegt wird.
 .TP
-.B "[-L]"
+.B "[\-L]"
 Aktiviert 3-Draht-Betrieb.  Das Terminal wird in die CLOCAL Betriebsart
 geschaltet und der Tr\(:ager wird nicht \(:uberwacht.
 .TP
-.B "[-p Protokoll]"
+.B "[\-p Protokoll]"
 Setzt ein spezifisches Protkoll um eine Leitung zu benutzen.  Die
 Voreinstellung ist
 .BR cslip ,
@@ -79,7 +79,7 @@ Verbindungen sollte stattdessen das
 .B axattach
 Programm verwendet werden.
 .TP
-.B "[-s Geschwindigkeit]"
+.B "[\-s Geschwindigkeit]"
 Setzt eine von der Voreinstellung abweichende \(:Ubertragungseschwindigkeit.
 .PP
 Werden keine Argument gegeben, sie wird das aktuelle Terminal, das ist
diff --git a/man/en_US/arp.8 b/man/en_US/arp.8
index d859b46..751cf7f 100644
--- a/man/en_US/arp.8
+++ b/man/en_US/arp.8
@@ -1,56 +1,111 @@
-.TH ARP 8 "5 Jan 1999" "net-tools" "Linux Programmer's Manual"
+.TH ARP 8 "2007-12-01" "net\-tools" "Linux Programmer's Manual"
 .SH NAME
 arp \- manipulate the system ARP cache
 .SH SYNOPSIS
 .B arp 
 .RB [ \-vn ] 
-.RB [ "\-H type" ] 
-.RB [ "-i if" ] 
-.B -a 
-.RB [ hostname ]
+.RB [ \-H 
+.IR type ] 
+.RB [ \-i
+.IR if ] 
+.RB [ \-a ] 
+.RI [ hostname ]
 .PP
 .B arp 
 .RB [ \-v ]
-.RB [ "\-i if" ] 
-.B "\-d hostname"
+.RB [ \-i
+.IR if ] 
+.B \-d 
+.I hostname
 .RB [ pub ]
 .PP
 .B arp 
 .RB [ \-v ] 
-.RB [ "\-H type" ] 
-.RB [ "\-i if" ] 
-.B -s hostname hw_addr
+.RB [ \-H
+.IR type ] 
+.RB [ \-i
+.IR if ] 
+.B \-s
+.I hostname hw_addr
 .RB [ temp ] 
 .PP
 .B arp 
 .RB [ \-v ] 
-.RB [ "\-H type" ] 
-.RB [ "\-i if" ] 
-.B -s hostname hw_addr
-.RB [ "netmask nm" ] 
+.RB [ \-H
+.IR type ] 
+.RB [ \-i
+.IR if ] 
+.B \-s
+.I hostname hw_addr
+.RB [ netmask
+.IR nm ] 
 .B pub
 .PP
 .B arp 
 .RB [ \-v ] 
-.RB [ "\-H type" ] 
-.RB [ "\-i if" ] 
-.B -Ds hostname ifa
-.RB [ "netmask nm" ] 
+.RB [ \-H
+.IR type ] 
+.RB [ \-i
+.IR if ] 
+.B \-Ds 
+.I hostname
+.I ifname
+.RB [ netmask
+.IR nm ] 
 .B pub
 .PP
 .B arp 
 .RB [ \-vnD ]
-.RB [ "\-H type" ] 
-.RB [ "-i if" ]
-.B -f [filename]
+.RB [ \-H 
+.IR type ] 
+.RB [ \-i
+.IR if ]
+.B \-f 
+.RI [ filename ]
 
 .SH DESCRIPTION
 .B Arp
-manipulates the kernel's ARP cache in various ways.  The primary options
-are clearing an address mapping entry and manually setting up one.  For
-debugging purposes, the
+manipulates or displays the kernel's IPv4 network neighbour cache. It can add
+entries to the table, delete one or display the current content.
+
+.B ARP
+stands for Address Resolution Protocol, which is used to find the media
+access control address of a network neighbour for a given IPv4 Address.
+.SH MODES
 .B arp
-program also allows a complete dump of the ARP cache.
+with no mode specifier will print the current content of the table. It is
+possible to limit the number of entries printed, by specifying an hardware
+address type, interface name or host address.
+
+.B arp -d
+.I address
+will delete a ARP table entry. Root or netadmin priveledge is required to do
+this. The entry is found by IP address. If a hostname is given, it will be
+resolved before looking up the entry in the ARP table.
+
+.B arp -s
+.I address hw_addr
+is used to set up a new table entry. The format of the 
+.I hw_addr
+parameter is dependent on the hardware class, but for most classes one can
+assume that the usual presentation can be used.  For the Ethernet class,
+this is 6 bytes in hexadecimal, separated by colons. When adding proxy arp
+entries (that is those with the
+.BR pub lish 
+flag set a 
+.B netmask 
+may be specified to proxy arp for entire subnets. This is not good
+practice, but is supported by older kernels because it can be
+useful. If the
+.B temp
+flag is not supplied entries will be permanent stored into the ARP
+cache. To simplyfy setting up entries for one of your own network interfaces, you can use the
+.B "arp \-Ds"
+.I address ifname
+form. In that case the hardware address is taken from the interface with the
+specified name.
+
+.br
 .SH OPTIONS
 .TP
 .B "\-v, \-\-verbose"
@@ -60,7 +115,7 @@ Tell the user what is going on by being verbose.
 shows numerical addresses instead of trying to determine symbolic host, port
 or user names.
 .TP
-.B "\-H type, \-\-hw-type type"
+.B "\-H type, \-\-hw\-type type"
 When setting or reading the ARP cache, this optional parameter tells
 .B arp
 which class of entries it should check for.  The default value of
@@ -76,21 +131,13 @@ Other values might include network technologies such as
 and
 .RB "NET/ROM (" netrom ")."
 .TP
-.B "\-a [hostname], \-\-display [hostname]"
-Shows the entries of the specified hosts.  If the
-.B hostname
-parameter is not used,
-.B all
-entries will be displayed.
-.TP
-.B "\-d hostname, \-\-delete hostname"
-Remove any entry for the specified host.  This can be used if the
-indicated host is brought down, for example.
+.B \-a
+Use alternate BSD style output format (with no fixed columns).
 .TP
 .B "\-D, \-\-use-device"
-Use the interface
-.BR ifa "'s"
-hardware address.
+Instead of a hw_addr, the given argument is the name of an interface. 
+.B arp
+will use the MAC address of that interface for the table entry. This is usually the best option to set up a proxy ARP entry to yourself.
 .TP
 .B "\-i If, \-\-device If"
 Select an interface. When dumping the ARP cache only entries matching
@@ -106,40 +153,22 @@ be answered.
 .B NOTE:
 This has to be different from the interface to which the IP
 datagrams will be routed.
-.TP
-.B "\-s hostname hw_addr, \-\-set hostname"
-Manually create an ARP address mapping entry for host
-.B hostname
-with hardware address set to
-.B hw_addr
-.  The format of the hardware address is dependent on the hardware
-class, but for most classes one can assume that the usual presentation
-can be used.  For the Ethernet class, this is 6 bytes in hexadecimal,
-separated by colons. When adding proxy arp entries (that is those with
-the 
-.BR pub lish 
-flag set a 
-.B netmask 
-may be specified to proxy arp for entire subnets. This is not good
-practice, but is supported by older kernels because it can be
-useful. If the
-.B temp
-flag is not supplied entries will be permanent stored into the ARP
-cache.
-.br
 .B NOTE:
 As of kernel 2.2.0 it is no longer possible to set an ARP entry for an 
 entire subnet. Linux instead does automagic proxy arp when a route
 exists and it is forwarding. See 
 .BR arp (7)
-for details.
+for details. Also the
+.B dontpub
+option which is available for delete and set operations cannot be 
+used with 2.4 and newer kernels.
 .TP
 .B "\-f filename, \-\-file filename"
 Similar to the
 .B \-s
 option, only this time the address info is taken from file
-.B filename
-.  This can be used if ARP entries for a lot of hosts have to be
+.B filename.
+This can be used if ARP entries for a lot of hosts have to be
 set up.  The name of the data file is very often
 .IR /etc/ethers , 
 but this is not official. If no filename is specified /etc/ethers
@@ -167,8 +196,18 @@ flag. Permanent entries are marked with
 and published entries have the
 .B P
 flag.
+.SH EXSAMPLES
+.B /usr/sbin/arp -i eth0 -Ds 10.0.0.2 eth1 pub
+
+This will answer ARP requests for 10.0.0.2 on eth0 with the MAC address for
+eth1.
+
+.B /usr/sbin/arp -i eth1 -d 10.0.0.1
+
+Delete the ARP table entry for 10.0.0.1 on interface eth1. This will match
+published proxy ARP entries and permanent entries.
 .SH FILES
-.I /proc/net/arp,
+.I /proc/net/arp
 .br
 .I /etc/networks
 .br
@@ -178,5 +217,4 @@ flag.
 .SH SEE ALSO
 rarp(8), route(8), ifconfig(8), netstat(8)
 .SH AUTHORS
-Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org> with a lot of improvements
-from net-tools Maintainer Bernd Eckenfels <net-tools@lina.inka.de>.
+Fred N. van Kempen <waltje@uwalt.nl.mugnet.org>, Bernd Eckenfels <net\-tools@lina.inka.de>.
diff --git a/man/en_US/ethers.5 b/man/en_US/ethers.5
index f3ba116..23ac3cf 100644
--- a/man/en_US/ethers.5
+++ b/man/en_US/ethers.5
@@ -1,4 +1,4 @@
-.TH ETHERS 5 "April 26th, 1996" "" "File formats"
+.TH ETHERS 5 "May 15th, 2005" "" "File formats"
 .SH NAME \"{{{roff}}}\"{{{
 ethers \- Ethernet address to IP number database
 .\"}}}
@@ -10,8 +10,8 @@ IP numbers, one line for each IP number:
 \fIEthernet-address\fP  \fIIP-number\fP
 .RE
 .sp
-The two items are separated by any number of SPACE and/or TAB char
-acters.   A \fB#\fP at the beginning of a line starts a comment
+The two items are separated by any number of SPACE and/or TAB characters.
+A \fB#\fP at the beginning of a line starts a comment
 which extends to the end of the line.  The \fIEthernet-address\fP is
 written as
 .IR x : x : x : x : x : x ,
diff --git a/man/en_US/hostname.1 b/man/en_US/hostname.1
index cea3f6e..2d17976 100644
--- a/man/en_US/hostname.1
+++ b/man/en_US/hostname.1
@@ -1,4 +1,4 @@
-.TH HOSTNAME 1 "28 Jan 1996" "net-tools" "Linux Programmer's Manual"
+.TH HOSTNAME 1 "28 Jan 1996" "net\-tools" "Linux Programmer's Manual"
 
 .SH NAME
 hostname \- show or set the system's host name
@@ -23,7 +23,7 @@ nodename \- show or set the system's DECnet node name
 .RB [ \-f ]
 .RB [ \-\-fqdn ]
 .RB [ \-i ]
-.RB [ \-\-ip-address ]
+.RB [ \-\-ip\-address ]
 .RB [ \-\-long ]
 .RB [ \-s ]
 .RB [ \-\-short ]
@@ -181,7 +181,7 @@ part of the FQDN) in the \fI/etc/hosts\fR file.
 .I "\-h, \-\-help"
 Print a usage message and exit.
 .TP
-.I "\-i, \-\-ip-address"
+.I "\-i, \-\-ip\-address"
 Display the IP address(es) of the host.
 .TP
 .I "\-n, \-\-node"
@@ -205,9 +205,9 @@ Display the NIS domain name. If a parameter is given (or
 .SH FILES
 .B /etc/hosts
 .SH AUTHOR
-Peter Tobias, <tobias@et-inf.fho-emden.de>
+Peter Tobias, <tobias@et\-inf.fho\-emden.de>
 .br
-Bernd Eckenfels, <net-tools@lina.inka.de> (NIS and manpage).
+Bernd Eckenfels, <net\-tools@lina.inka.de> (NIS and manpage).
 .br
 Steve Whitehouse, <SteveW@ACM.org> (DECnet support and manpage).
 
diff --git a/man/en_US/ifconfig.8 b/man/en_US/ifconfig.8
index e75cf59..0ca6cf7 100644
--- a/man/en_US/ifconfig.8
+++ b/man/en_US/ifconfig.8
@@ -1,10 +1,10 @@
-.TH IFCONFIG 8 "14 August 2000" "net-tools" "Linux Programmer's Manual"
+.TH IFCONFIG 8 "2007-12-02" "net\-tools" "Linux Programmer's Manual"
 .SH NAME
 ifconfig \- configure a network interface
 .SH SYNOPSIS
-.B "ifconfig [interface]"
+.B "ifconfig [-v] [-a] [-s] [interface]"
 .br
-.B "ifconfig interface [aftype] options | address ..."
+.B "ifconfig [-v] interface [aftype] options | address ..."
 .SH DESCRIPTION
 .B Ifconfig
 is used to configure the kernel-resident network interfaces.  It is
@@ -18,7 +18,7 @@ a single
 .B interface
 argument is given, it displays the status of the given interface
 only; if a single
-.B -a
+.B \-a
 argument is given, it displays the status of all interfaces, even
 those that are down.  Otherwise, it configures an interface.
 
@@ -41,11 +41,27 @@ supported address families include
 (AMPR Packet radio).
 .SH OPTIONS
 .TP
+.B -a
+display all interfaces which are currently available, even if down
+.TP
+.B -s
+display a short list (like netstat \-i)
+.TP
+.B -v
+be more verbose for some error conditions
+.TP
 .B interface
 The name of the interface.  This is usually a driver name followed by
 a unit number, for example
 .B eth0
-for the first Ethernet interface.
+for the first Ethernet interface. If your kernel supports alias interfaces,
+you can specify them with 
+.B eth0:0
+for the first alias of eth0. You can use them to assign a second address. To
+delete an alias interface use
+.BR "ifconfig eth0:0 down" .
+Note: for every scope (i.e. same net with address/netmask combination) all
+aliases are deleted, if you delete the first (primary).
 .TP
 .B up
 This flag causes the interface to be activated.  It is implicitly
@@ -122,13 +138,13 @@ are
 can be used to tell the driver to auto-sense the media.  Again, not
 all drivers can do this.
 .TP
-.B "[-]broadcast [addr]"
+.B "[\-]broadcast [addr]"
 If the address argument is given, set the protocol broadcast
 address for this interface.  Otherwise, set (or clear) the
 .B IFF_BROADCAST
 flag for the interface.
 .TP
-.B "[-]pointopoint [addr]"
+.B "[\-]pointopoint [addr]"
 This keyword enables the
 .B point-to-point
 mode of an interface, meaning that it is a direct link between two
@@ -173,11 +189,15 @@ alias interfaces anymore. The statistics printed for the original address
 are shared with all alias addresses on the same device. If you want per-address
 statistics you should add explicit accounting
 rules for the address using the 
-.BR ipchains(8)
+.BR ipchains (8)
+or
+.BR iptables (8)
 command.
 .LP
-Interrupt problems with Ethernet device drivers fail with EAGAIN. See
-.I http://cesdis.gsfc.nasa.gov/linux/misc/irq-conflict.html
+Interrupt problems with Ethernet device drivers fail with EAGAIN
+.I (SIOCSIIFLAGS: Resource temporarily unavailable)
+it is most likely a interrupt conflict. See
+.I http://www.scyld.com/expert/irq\-conflict.html
 for more information.
 .SH FILES
 .I /proc/net/socket 
@@ -189,7 +209,9 @@ for more information.
 While appletalk DDP and IPX addresses will be displayed they cannot be
 altered by this command.
 .SH SEE ALSO
-route(8), netstat(8), arp(8), rarp(8), ipchains(8)
+route(8), netstat(8), arp(8), rarp(8), ipchains(8), iptables(8), ifup(8), interfaces(5).
+.br
+http://physics.nist.gov/cuu/Units/binary.html - Prefixes for binary multiples
 .SH AUTHORS
 Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 .br
@@ -198,3 +220,5 @@ Alan Cox, <Alan.Cox@linux.org>
 Phil Blundell, <Philip.Blundell@pobox.com>
 .br
 Andi Kleen
+.br
+Bernd Eckenfels, <net\-tools@lina.inka.de>
diff --git a/man/en_US/mii-tool.8 b/man/en_US/mii-tool.8
index 6b773ec..16ae13d 100644
--- a/man/en_US/mii-tool.8
+++ b/man/en_US/mii-tool.8
@@ -1,13 +1,13 @@
 .\" Copyright (C) 2000 David A. Hinds -- dhinds@pcmcia.sourceforge.org
 .\" mii-tool.8 1.5 2000/04/25 22:58:19
 .\"
-.TH MII-TOOL 8 "2000/04/25 22:58:19" "net-tools"
+.TH MII\-TOOL 8 "2004/03/28 23:30:00" "net\-tools"
 
 .SH NAME
-mii-tool \- view, manipulate media-independent interface status
+mii\-tool \- view, manipulate media-independent interface status
 
 .SH SYNOPSIS
-.B mii-tool
+.B mii\-tool
 [\fB\-v\fR, \fB\-\-verbose\fR]
 [\fB\-V\fR, \fB\-\-version\fR]
 [\fB\-R\fR, \fB\-\-reset\fR]
@@ -32,12 +32,12 @@ single-speed hubs, are unable to autonegotiate.  To handle such
 devices, the MII protocol also allows for establishing a link by
 simply detecting either a 10baseT or 100baseT link beat.  The \fB\-F\fR
 or \fB\-\-force\fR options can be used to force the MII to operate in
-one mode, instead of autonegotiating.  The \fB\-A\fR and \fB-F\fR
+one mode, instead of autonegotiating.  The \fB\-A\fR and \fB\-F\fR
 options are mutually exclusive.
 .PP
 The default short output reports the negotiated link speed and link
 status for each interface.  If an interface or interfaces are not
-specified on the command line, then \fBmii-tool\fR will check any
+specified on the command line, then \fBmii\-tool\fR will check any
 available interfaces from \fBeth0\fR through \fBeth7\fR.
 .SH OPTIONS
 .TP
@@ -59,7 +59,7 @@ Watch interface(s) and report changes in link status.  The MII
 interfaces are polled at one second intervals.
 .TP
 \fB\-l\fR, \fB\-\-log\fR
-Used with \fB-w\fR, records link status changes in the system log
+Used with \fB\-w\fR, records link status changes in the system log
 instead of printing on standard output.
 .TP
 \fB\-F\fI media\fR, \fB\-\-force=\fImedia\fR
@@ -72,7 +72,24 @@ media technologies.  Multiple technologies should be separated by
 commas.  Valid media are \fB100baseT4\fR, \fB100baseTx-FD\fR,
 \fB100baseTx-HD\fR, \fB10baseT-FD\fR, and \fB10baseT-HD\fR.
 
+.SH DIAGNOSTICS
+.TP
+SIOCGMIIPHY on 'eth?' failed: Invalid argument
+If the interface is not running (up), kernel will refuse to report its link state.
+.TP
+SIOCGMIIPHY on 'eth?' failed: Operation not permitted
+Most kernels restrict access to root.
+.TP
+SIOCGMIIPHY on 'eth?' failed: No such device
+This error is shown, if the kernel does not know about the named device.
+.TP
+SIOCGMIIPHY on 'eth?' failed: Operation not supported 
+The interface in question does not support MII queries. Most likely, it does not have 
+MII transceivers, at all.
+
 .SH AUTHORS
 David Hinds \- dhinds@pcmcia.sourceforge.org
 .br
 Donald Becker \- becker@scyld.com
+.br
+Bernd Eckenfels \- ecki@debian.org
diff --git a/man/en_US/nameif.8 b/man/en_US/nameif.8
index ff2430f..d9919f2 100644
--- a/man/en_US/nameif.8
+++ b/man/en_US/nameif.8
@@ -1,10 +1,10 @@
-.TH NAMEIF 8 "18 Oct 2000" "net-tools" "Linux's Administrator's Manual"
+.TH NAMEIF 8 "18 Oct 2000" "net\-tools" "Linux's Administrator's Manual"
 .SH NAME
 nameif \- name network interfaces based on MAC addresses
 .SH SYNOPSIS
-.B "nameif [-c configfile] [-s]"
+.B "nameif [\-c configfile] [\-s]"
 .br
-.B "nameif [-c configfile] [-s] {interface macaddress}"
+.B "nameif [\-c configfile] [\-s] {interface macaddress}"
 .SH DESCRIPTION
 .B nameif 
 renames network interfaces based on mac addresses. When no arguments are
@@ -18,11 +18,11 @@ looks for the interface with the given MAC address and renames it to the
 name given.
 
 When the 
-.I -s
+.I \-s
 argument is given all error messages go to the syslog.
 
 When the 
-.I -c 
+.I \-c 
 argument is given with a file name that file is read instead of /etc/mactab.
 
 .SH NOTES
diff --git a/man/en_US/netstat.8 b/man/en_US/netstat.8
index b33996a..2a1a0be 100644
--- a/man/en_US/netstat.8
+++ b/man/en_US/netstat.8
@@ -8,7 +8,7 @@
 .\" Modified: Tuan Hoang tqhoang@bigfoot.com 
 .\"
 .\"
-.TH NETSTAT 8 "19 December 2000" "net-tools" "Linux Programmer's Manual"
+.TH NETSTAT 8 "2008-11-16" "net\-tools" "Linux Programmer's Manual"
 
 .SH NAME
 netstat \- Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships
@@ -23,7 +23,7 @@ netstat \- Print network connections, routing tables, interface statistics, masq
 .RB [ \-\-listening | \-l ]
 .RB [ \-\-all | \-a ]
 .RB [ \-\-numeric | \-n ]
-.RB [ \-\-numeric-hosts ] [ \-\-numeric-ports ] [ \-\-numeric-ports ]
+.RB [ \-\-numeric-hosts "] [" \-\-numeric-ports "] [" \-\-numeric\-users ]
 .RB [ \-\-symbolic | \-N ]
 .RB [ \-\-extend | \-e  [ \-\-extend | \-e] ]
 .RB [ \-\-timers | \-o ]
@@ -37,31 +37,30 @@ netstat \- Print network connections, routing tables, interface statistics, masq
 .RB [ \-\-extend | \-e  [ \-\-extend | \-e] ]
 .RB [ \-\-verbose | \-v ]
 .RB [ \-\-numeric | \-n ]
-.RB [ \-\-numeric-hosts ] [ \-\-numeric-ports ] [ \-\-numeric-ports ]
+.RB [ \-\-numeric\-hosts "] [" \-\-numeric\-ports "] [" \-\-numeric\-users ]
 .RB [ \-\-continuous | \-c]
 .P
 .B netstat
 .RB { \-\-interfaces | \-i }
-.RI [ iface ]
 .RB [ \-\-all | \-a ]
 .RB [ \-\-extend | \-e  [ \-\-extend | \-e] ]
 .RB [ \-\-verbose | \-v ]
 .RB [ \-\-program | \-p ]
 .RB [ \-\-numeric | \-n ]
-.RB [ \-\-numeric-hosts ] [ \-\-numeric-ports ] [ \-\-numeric-ports ]
+.RB [ \-\-numeric-hosts "] [" \-\-numeric-ports "] [" \-\-numeric-users ]
 .RB [ \-\-continuous | \-c]
 .P
 .B netstat
 .RB { \-\-groups | \-g }
 .RB [ \-\-numeric | \-n ]
-.RB [ \-\-numeric-hosts ] [ \-\-numeric-ports ] [ \-\-numeric-ports ]
+.RB [ \-\-numeric\-hosts "] [" \-\-numeric\-ports "] [" \-\-numeric\-users ]
 .RB [ \-\-continuous | \-c]
 .P
 .B netstat
 .RB { \-\-masquerade | \-M }
 .RB [ \-\-extend | \-e ]
 .RB [ \-\-numeric | \-n ]
-.RB [ \-\-numeric-hosts ] [ \-\-numeric-ports ] [ \-\-numeric-ports ]
+.RB [ \-\-numeric\-hosts "] [" \-\-numeric\-ports "] [" \-\-numeric\-users ]
 .RB [ \-\-continuous | \-c]
 .P
 .B netstat
@@ -78,6 +77,8 @@ netstat \- Print network connections, routing tables, interface statistics, masq
 .P
 .IR address_family_options :
 .PP
+.RB [ -4 ]
+.RB [ -6 ]
 .RB [ \-\-protocol= { inet , unix , ipx , ax25 , netrom , ddp }[, ...] ]
 .RB [ \-\-unix | \-x ] 
 .RB [ \-\-inet | \-\-ip ]
@@ -98,12 +99,17 @@ displays a list of open sockets.  If you don't specify any
 address families, then the active sockets of all configured address
 families will be printed.
 .SS "\-\-route , \-r"
-Display the kernel routing tables.
+Display the kernel routing tables. See the description in 
+.BR route (8) 
+for details. 
+.B netstat -r 
+and 
+.B route -e 
+produce the same output.
 .SS "\-\-groups , \-g"
 Display multicast group membership information for IPv4 and IPv6.
-.SS "\-\-interface=\fIiface \fR, \fB\-i"
-Display a table of all network interfaces, or the specified
-.IR iface ) .
+.SS "\-\-interfaces, \-i"
+Display a table of all network interfaces.
 .SS "\-\-masquerade , \-M"
 Display a list of masqueraded connections.
 .SS "\-\-statistics , \-s"
@@ -112,16 +118,19 @@ Display summary statistics for each protocol.
 .SS "\-\-verbose , \-v"
 Tell the user what is going on by being verbose. Especially print some
 useful information about unconfigured address families.
+.SS "\-\-wide , \-W"
+Do not truncate IP addresses by using output as wide as needed. This is
+optional for now to not break existing scripts.
 .SS "\-\-numeric , \-n"
 Show numerical addresses instead of trying to determine symbolic host, port
 or user names.
-.SS "\-\-numeric-hosts"
+.SS "\-\-numeric\-hosts"
 shows numerical host addresses but does not affect the resolution of
 port or user names.
-.SS "\-\-numeric-ports"
+.SS "\-\-numeric\-ports"
 shows numerical port numbers but does not affect the resolution of
 host or user names.
-.SS "\-\-numeric-users"
+.SS "\-\-numeric\-users"
 shows numerical user IDs but does not affect the resolution of host or
 port names.
 
@@ -164,22 +173,21 @@ Show the PID and name of the program to which each socket belongs.
 Show only listening sockets.  (These are omitted by default.)
 .SS "\-a, \-\-all"
 Show both listening and non-listening sockets.  With the
-.B --interfaces
-option, show interfaces that are not marked 
+.B \-\-interfaces
+option, show interfaces that are not up
 .SS "\-F"
 Print routing information from the FIB.  (This is the default.)
 .SS "\-C"
 Print routing information from the route cache.
-.IR UP .
 .P
 .SH OUTPUT
 .P
 .SS Active Internet connections \fR(TCP, UDP, raw)\fR
 .SS "Proto" 
 The protocol (tcp, udp, raw) used by the socket. 
-.SS "Recv-Q"
+.SS "Recv\-Q"
 The count of bytes not copied by the user program connected to this socket.
-.SS "Send-Q"
+.SS "Send\-Q"
 The count of bytes not acknowledged by the remote host.
 .SS "Local Address" 
 Address and port number of the local end of the socket.  Unless the
@@ -221,7 +229,7 @@ TIME_WAIT
 The socket is waiting after close to handle packets still in the network.
 .TP
 .I
-CLOSED
+CLOSE
 The socket is not being used.
 .TP
 .I
@@ -255,7 +263,7 @@ The username or the user id (UID) of the owner of the socket.
 .SS "PID/Program name"
 Slash-separated pair of the process id (PID) and process name of the 
 process that owns the socket.
-.B --program
+.B \-\-program
 causes this column to be included.  You will also need
 .I superuser
 privileges to see this information on sockets you don't own.  This
@@ -358,7 +366,7 @@ to the socket.
 .PP
 .SH NOTES
 Starting with Linux release 2.2 
-.B netstat -i 
+.B netstat \-i 
 does not show interface statistics for alias interfaces. To get per
 alias interface counters you need to setup explicit rules using the
 .BR ipchains(8) 
@@ -438,12 +446,12 @@ as it is viewed. This is unlikely to occur.
 .P
 .SH AUTHORS
 The netstat user interface was written by Fred Baumgarten
-<dc6iq@insu1.etec.uni-karlsruhe.de> the man page basically
+<dc6iq@insu1.etec.uni\-karlsruhe.de>, the man page basically
 by Matt Welsh <mdw@tc.cornell.edu>. It was updated by
 Alan Cox <Alan.Cox@linux.org> but could do with a bit more
 work.  It was updated again by Tuan Hoang
 <tqhoang@bigfoot.com>.
 .br
-The man page and the command included in the net-tools
+The man page and the command included in the net\-tools
 package is totally rewritten by Bernd Eckenfels 
 <ecki@linux.de>.
diff --git a/man/en_US/rarp.8 b/man/en_US/rarp.8
index e462799..bf60faf 100644
--- a/man/en_US/rarp.8
+++ b/man/en_US/rarp.8
@@ -1,20 +1,20 @@
-.TH RARP 8 "4 August 1997" "net-tools" "Linux Programmer's Manual"
+.TH RARP 8 "4 August 1997" "net\-tools" "Linux Programmer's Manual"
 .SH NAME
 rarp \- manipulate the system RARP table
 .SH SYNOPSIS
-.B "rarp [-V] [--version] [-h] [--help]"
+.B "rarp [\-V] [\-\-version] [\-h] [\-\-help]"
 .br
-.B "rarp -a"
+.B "rarp \-a"
 .br
-.B "rarp [-v] -d hostname ..."
+.B "rarp [\-v] \-d hostname ..."
 .br
-.B "rarp [-v] [-t type] -s hostname hw_addr"
+.B "rarp [\-v] [\-t type] \-s hostname hw_addr"
 .SH NOTE
 .P
 This program is obsolete.  From version 2.3, the Linux kernel 
 no longer contains RARP support.  For a replacement RARP daemon, see
 .I
-ftp://ftp.dementia.org/pub/net-tools
+ftp://ftp.dementia.org/pub/net\-tools
 .SH DESCRIPTION
 .B Rarp
 manipulates the kernel's RARP table in various ways.  The primary options
@@ -61,8 +61,8 @@ Remove all RARP entries for the specified host.
 Create a RARP address mapping entry for host
 .B hostname
 with hardware address set to
-.B hw_addr
-.  The format of the hardware address is dependent on the hardware
+.BR hw_addr .
+The format of the hardware address is dependent on the hardware
 class, but for most classes one can assume that the usual presentation
 can be used.  For the Ethernet class, this is 6 bytes in hexadecimal,
 separated by colons.
diff --git a/man/en_US/route.8 b/man/en_US/route.8
index f59c074..29927fe 100644
--- a/man/en_US/route.8
+++ b/man/en_US/route.8
@@ -1,4 +1,4 @@
-.TH ROUTE 8 "2 January 2000" "net-tools" "Linux Programmer's Manual"
+.TH ROUTE 8 "2007-12-02" "net\-tools" "Linux Programmer's Manual"
 .SH NAME
 route \- show / manipulate the IP routing table
 .SH SYNOPSIS
@@ -51,7 +51,7 @@ If]
 .RB [ \-V ] 
 .RB [ \-\-version ]
 .RB [ \-h ]
-.RB [ \--help ]
+.RB [ \-\-help ]
 .SH DESCRIPTION
 .B Route
 manipulates the kernel's IP routing tables.  Its primary use is to set
@@ -73,16 +73,16 @@ displays the current contents of the routing tables.
 .SH OPTIONS
 .TP
 .B \-A family
-use the specified address family (eg `inet'; use `route --help' for a full 
+use the specified address family (eg `inet'; use `route \-\-help' for a full 
 list).
 
 .TP 
-.B -F
+.B \-F
 operate on the kernel's FIB (Forwarding Information Base) routing
 table. 
 This is the default.
 .TP 
-.B -C
+.B \-C
 operate on the kernel's routing cache.
 
 .TP
@@ -96,7 +96,7 @@ nameserver has vanished.
 .TP
 .B \-e
 use
-.BR netstat (8)-format
+.BR netstat (8)\-format
 for displaying the routing table.
 .B \-ee 
 will generate a very long line with all parameters from the routing table.
@@ -117,7 +117,7 @@ the
 .B target
 is a network.
 .TP
-.B -host
+.B \-host
 the
 .B target 
 is a host.
@@ -141,7 +141,7 @@ set the metric field in the routing table (used by routing daemons) to M.
 set the TCP Maximum Segment Size (MSS) for connections over this route
 to M bytes. 
 The default is the device MTU minus headers, or a lower MTU when path mtu 
-discovery occured. This setting can be used to force smaller TCP packets on the
+discovery occurred. This setting can be used to force smaller TCP packets on the
 other end when path mtu discovery does not work (usually because of
 misconfigured firewalls that block ICMP Fragmentation Needed)
 .TP 
@@ -179,24 +179,27 @@ modifiers (metric - netmask - gw - dev) doesn't matter.
 
 .SH EXAMPLES
 .TP
-.B route add -net 127.0.0.0
-adds the normal loopback entry, using netmask 255.0.0.0 (class A net,
-determined from the destination address) and associated with the 
-"lo" device (assuming this device was prviously set up correctly with
+.B route add \-net 127.0.0.0 netmask 255.0.0.0 dev lo
+adds the normal loopback entry, using netmask 255.0.0.0 and associated with the 
+"lo" device (assuming this device was previously set up correctly with
 .BR ifconfig (8)). 
 
 .TP 
-.B route add -net 192.56.76.0 netmask 255.255.255.0 dev eth0
-adds a route to the network 192.56.76.x via 
-"eth0". The Class C netmask modifier is not really necessary here because
-192.* is a Class C IP address. The word "dev" can be omitted here. 
+.B route add \-net 192.56.76.0 netmask 255.255.255.0 dev eth0
+adds a route to the local network 192.56.76.x via 
+"eth0".  The word "dev" can be omitted here. 
 
 .TP
-.B route add default gw mango-gw
+.B route del default
+deletes the current default route, which is labeled "default" or 0.0.0.0
+in the destination field of the current routing table.
+
+.TP
+.B route add default gw mango\-gw
 adds a default route (which will be used if no other route matches).
-All packets using this route will be gatewayed through "mango-gw". The
+All packets using this route will be gatewayed through "mango\-gw". The
 device which will actually be used for that route depends on how we
-can reach "mango-gw" - the static route to "mango-gw" will have to be
+can reach "mango\-gw" - the static route to "mango\-gw" will have to be
 set up before. 
 
 .TP
@@ -205,18 +208,18 @@ Adds the route to the "ipx4" host via the SLIP interface (assuming that
 "ipx4" is the SLIP host).
 
 .TP
-.B route add -net 192.57.66.0 netmask 255.255.255.0 gw ipx4
+.B route add \-net 192.57.66.0 netmask 255.255.255.0 gw ipx4
 This command adds the net "192.57.66.x" to be gatewayed through the former
 route to the SLIP interface.
 
 .TP
-.B route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0
+.B route add \-net 224.0.0.0 netmask 240.0.0.0 dev eth0
 This is an obscure one documented so people know how to do it. This sets
 all of the class D (multicast) IP routes to go via "eth0". This is the
 correct normal configuration line with a multicasting kernel. 
 
 .TP
-.B route add -net 10.0.0.0 netmask 255.0.0.0 reject
+.B route add \-net 10.0.0.0 netmask 255.0.0.0 reject
 This installs a rejecting route for the private network "10.x.x.x."
 
 .LP
@@ -282,14 +285,14 @@ recent kernels, but may be needed by routing daemons.
 Number of references to this route. (Not used in the Linux kernel.)
 .TP
 .B Use
-Count of lookups for the route.  Depending on the use of -F and -C this will
-be either route cache misses (-F) or hits (-C).
+Count of lookups for the route.  Depending on the use of \-F and \-C this will
+be either route cache misses (\-F) or hits (\-C).
 .TP
 .B Iface
 Interface to which packets for this route will be sent.
 .TP
 .B MSS 
-Default maximum segement size for TCP connections over this route.
+Default maximum segment size for TCP connections over this route.
 .TP
 .B Window  
 Default window size for TCP connections over this route.
@@ -323,4 +326,4 @@ for Linux was originally written by Fred N.  van Kempen,
 Linus Torvalds for pl15. Alan Cox added the mss and window options for
 Linux 1.1.22. irtt support and merged with netstat from Bernd Eckenfels.
 .SH AUTHOR
-Currently maintained by Phil Blundell <Philip.Blundell@pobox.com>.
+Currently maintained by Phil Blundell <Philip.Blundell@pobox.com> and Bernd Eckenfels <net-tools@lina.inka.de>.
diff --git a/man/en_US/slattach.8 b/man/en_US/slattach.8
index 0c4c863..5d6f6a5 100644
--- a/man/en_US/slattach.8
+++ b/man/en_US/slattach.8
@@ -1,8 +1,8 @@
-.TH SLATTACH 8 "12 Feb 1994" "" ""
+.TH SLATTACH 8 "10 Oct 2006" "" ""
 .SH NAME
 slattach \- attach a network interface to a serial line
 .SH SYNOPSIS
-.B "slattach [-dehlLmnqv] [-c command] [-p proto] [-s speed] [tty]"
+.B "slattach [\-dehlLmnqv] [\-c command] [\-p proto] [\-s speed] [tty]"
 .br
 .SH DESCRIPTION
 .B Slattach
@@ -11,47 +11,48 @@ is a tiny little program that can be used to put a normal terminal
 you to use it for point-to-point links to other computers.
 .SH OPTIONS
 .TP
-.B "[-c command]"
+.B "[\-c command]"
 Execute
 .B command
 when the line is hung up. This can be used to run scripts or re-establish
 connections when a link goes down.
 .TP
-.B "[-d]"
+.B "[\-d]"
 Enable debugging output.  Useful when determining why a given
 setup doesn't work.
 .TP
-.B "[-h]"
+.B "[\-h]"
 Exit when the carrier is lost. This works on both /dev/tty and /dev/cua
 devices by directly monitoring the carrier status every 15 seconds.
-.B "[-v]"
+.TP
+.B "[\-v]"
 Enable verbose output.  Useful in shell scripts.
 .TP
-.B "[-q]"
+.B "[\-q]"
 Operate in quiet mode - no messages at all.
 .TP
-.B "[-l]"
+.B "[\-l]"
 Create an UUCP-style lockfile for the device in /var/lock.
 .TP
-.B "[-n]"
+.B "[\-n]"
 Equivalent to the "mesg n" command.
 .TP
-.B "[-m]"
+.B "[\-m]"
 Do \fBnot\fP initialize the line into 8 bits raw mode.
 .TP
-.B "[-e]"
+.B "[\-e]"
 Exit right after initializing device, instead of waiting for the
-line to hangup.
+line to hang up.
 .TP
-.B "[-L]"
+.B "[\-L]"
 Enable 3 wire operation. The terminal is moved into CLOCAL mode, 
 carrier watching is disabled.
 .TP
-.B "[-p proto]"
+.B "[\-p proto]"
 Set a specific kind of protocol to use on the line.  The default
 is set to
-.B "cslip"
-, i.e. compressed SLIP.  Other possible values are
+.BR "cslip" ,
+i.e. compressed SLIP.  Other possible values are
 .B "slip"
 (normal SLIP), 
 .B "adaptive"
@@ -70,7 +71,7 @@ to be active on the line. For kiss connections the
 .B axattach
 program should be used.
 .TP
-.B "[-s speed]"
+.B "[\-s speed]"
 Set a specific line speed, other than the default.
 .PP
 If no arguments are given, the current terminal line (usually: the
diff --git a/man/fr_FR/arp.8 b/man/fr_FR/arp.8
index df37e8b..55e7eae 100644
--- a/man/fr_FR/arp.8
+++ b/man/fr_FR/arp.8
@@ -1,12 +1,12 @@
-.TH ARP 8 "5 Jan 1999" "net-tools" "Linux Programmer's Manual"
+.TH ARP 8 "5 Jan 1999" "net\-tools" "Linux Programmer's Manual"
 .SH NOM
 arp \- manipule la table ARP du systme
 .SH SYNOPSIS
 .B arp 
 .RB [ \-vn ] 
 .RB [ "\-H type" ] 
-.RB [ "-i if" ] 
-.B -a 
+.RB [ "\-i if" ] 
+.B \-a 
 .RB [ nom_hte ]
 .PP
 .B arp 
@@ -19,14 +19,14 @@ arp \- manipule la table ARP du syst
 .RB [ \-v ] 
 .RB [ "\-H type" ] 
 .RB [ "\-i if" ] 
-.B -s nom_hte hw_addr
+.B \-s nom_hte hw_addr
 .RB [ temp ] 
 .PP
 .B arp 
 .RB [ \-v ] 
 .RB [ "\-H type" ] 
 .RB [ "\-i if" ] 
-.B -s nom_hte hw_addr
+.B \-s nom_hte hw_addr
 .RB [ "netmask nm" ] 
 .B pub
 .PP
@@ -34,15 +34,15 @@ arp \- manipule la table ARP du syst
 .RB [ \-v ] 
 .RB [ "\-H type" ] 
 .RB [ "\-i if" ] 
-.B -Ds nom_hte ifa
+.B \-Ds nom_hte ifa
 .RB [ "netmask nm" ] 
 .B pub
 .PP
 .B arp 
 .RB [ \-vnD ]
 .RB [ "\-H type" ] 
-.RB [ "-i if" ]
-.B -f nom_fichier
+.RB [ "\-i if" ]
+.B \-f nom_fichier
 
 .SH DESCRIPTION
 .B Arp
@@ -61,7 +61,7 @@ Dit 
 Affiche les adresses numriques au lieu d'essayer de dterminer les nom
 d'htes symboliques.
 .TP
-.B "\-H type, \-\-hw-type type"
+.B "\-H type, \-\-hw\-type type"
 En positionnant ou lisant les entres ARP, ce paramtre optionnel indique
  
 .B arp
@@ -92,7 +92,7 @@ les entr
 Enlve une entre pour l'hte spcifi.  Ceci peut tre
 utilis si l'hte concern ne fonctionne plus, par exemple.
 .TP
-.B "\-D, \-\-use-device"
+.B "\-D, \-\-use\-device"
 Utilise l'adresse matrielle de l'interface
 .BR ifa
 .
@@ -140,8 +140,8 @@ pour un sous r
 Similaire  l'option 
 .B \-s
 , mais cette fois les informations d'adresses sont prises dans le fichier
-.B nom_de_fichier
-. Ceci peut tre utilis si les entres ARP  configurer sont
+.BR nom_de_fichier .
+Ceci peut tre utilis si les entres ARP  configurer sont
 nombreuses.  Le nom du fichier de donnes est trs souvent nomm
 .B /etc/ethers
 , mais ce n'est pas officiel.
@@ -160,8 +160,8 @@ en notation d
 .LP
 Chaque entre complte se trouvant dans le cache ARP est marque de
 l'indicateur
-.B C
-. Les entres permanentes sont marques de l'indicateur
+.BR C .
+Les entres permanentes sont marques de l'indicateur
 .B M
 et les entres 'pub' ont l'indicateur
 .B P
@@ -178,7 +178,7 @@ et les entr
 rarp(8), route(8), ifconfig(8), netstat(8)
 .SH AUTEUR
 Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org> avec les amliorations
-apportes par le mainteneur des net-tools Bernd Eckenfels
-<net-tools@lina.inka.de>.
+apportes par le mainteneur des net\-tools Bernd Eckenfels
+<net\-tools@lina.inka.de>.
 .SH TRADUCTION
 Jean Michel VANSTEENE (vanstee@worldnet.fr)
diff --git a/man/fr_FR/hostname.1 b/man/fr_FR/hostname.1
index c4cd412..dad2f3f 100644
--- a/man/fr_FR/hostname.1
+++ b/man/fr_FR/hostname.1
@@ -1,4 +1,4 @@
-.TH HOSTNAME 1 "15 Mars 1999" "net-tools" "Linux Programmer's Manual"
+.TH HOSTNAME 1 "15 Mars 1999" "net\-tools" "Linux Programmer's Manual"
 .SH NOM
 hostname \- affiche ou dfinit le nom d'hte du systme
 .br
@@ -22,7 +22,7 @@ nodename \- affiche ou d
 .RB [ \-f ]
 .RB [ \-\-fqdn ]
 .RB [ \-i ]
-.RB [ \-\-ip-address ]
+.RB [ \-\-ip\-address ]
 .RB [ \-\-long ]
 .RB [ \-s ]
 .RB [ \-\-short ]
@@ -84,8 +84,8 @@ Appel
 .LP
 .B hostname
 fournit le nom du systme tel qu'il est retourn par la fonction
-.BR getdomainname (2)
-. Ceci est connu comme nom de domaine YP/NIS du systme.
+.BR getdomainname (2).
+Ceci est connu comme nom de domaine YP/NIS du systme.
 
 
 .LP
@@ -145,8 +145,8 @@ Le nom de domaine DNS est la partie suivant le premier point.
 .LP
 La faon dont vous pouvez le changer dpend de la configuration
 (habituellement dans 
-.IR /etc/host.conf )
-. Si le fichier 'hosts' est analys avant d'interroger le DNS ou 
+.IR /etc/host.conf ).
+Si le fichier 'hosts' est analys avant d'interroger le DNS ou 
 NIS) vous pouvez le changer dans le fichier 
 .IR /etc/hosts .
 
@@ -177,7 +177,7 @@ le nom FQDN et le nom de domaine (qui fait partie du FQDN) dans le fichier
 .I "\-h, \-\-help"
 Affiche un message d'aide et se termine.
 .TP
-.I "\-i, \-\-ip-address"
+.I "\-i, \-\-ip\-address"
 Affiche la (les) adresse(s) IP de l'hte.
 .TP
 .I "\-n, \-\-node"
@@ -203,9 +203,9 @@ Affiche le nom de domaine NIS. Si un param
 .SH FICHIERS
 .B /etc/hosts
 .SH AUTEURS
-Peter Tobias, <tobias@et-inf.fho-emden.de>
+Peter Tobias, <tobias@et\-inf.fho\-emden.de>
 .br
-Bernd Eckenfels, <net-tools@lina.inka.de> (NIS et pages de manuel).
+Bernd Eckenfels, <net\-tools@lina.inka.de> (NIS et pages de manuel).
 .br
 Steve Whitehouse, <SteveW@ACM.org> (Support DECnet et pages de manuel).
 .SH TRADUCTION
diff --git a/man/fr_FR/ifconfig.8 b/man/fr_FR/ifconfig.8
index 0c29eb0..765dfdf 100644
--- a/man/fr_FR/ifconfig.8
+++ b/man/fr_FR/ifconfig.8
@@ -1,4 +1,4 @@
-.TH IFCONFIG 8 "4 August 1997" "net-tools" "Linux Programmer's Manual"
+.TH IFCONFIG 8 "2007-12-02" "net\-tools" "Linux Programmer's Manual"
 .SH NOM
 ifconfig \- configure une interface rseau
 .SH SYNOPSIS
@@ -20,7 +20,7 @@ seul le param
 .B interface
 est donn, il affiche seulement l'tat de l'interface correspondante;
 si seul le paramtre
-.B -a
+.B \-a
 est fourni, il affiche l'tat de toutes les interfaces, mme celles qui
 ne sont pas actives.
 Autrement, il considre qu'il faut positionner de nouvelles valeurs.
@@ -60,14 +60,14 @@ le signe moins (\-) est pr
 .TP
 .B "[\-]promisc"
 Valide ou invalide le mode
-.B promiscuous
-.  S'il est valid, tous les paquets circulant sur le rseau
+.BR promiscuous .
+S'il est valid, tous les paquets circulant sur le rseau
 seront reus sur cette interface.
 .TP
 .B "[\-]allmulti"
 Valide ou invalide le fonctionnement de l'interface en mode
-.B all-multicast
-.  S'il est valid, tous les paquets multicast circulant sur le rseau
+.BR all-multicast .
+S'il est valid, tous les paquets multicast circulant sur le rseau
 seront reus sur cette interface.
 .TP
 .B "metric N"
@@ -128,14 +128,14 @@ permet d'indiquer au pilote de d
 utilis. Une fois de plus, tous les priphriques ne supportent pas cette
 option.
 .TP
-.B "[-]broadcast [adr]"
+.B "[\-]broadcast [adr]"
 Si l'adresse est galement donne, dfinit l'adresse broadcast
 protocolaire pour cette interface. Autrement, il permet d'armer (ou dsarmer)
 l'indicateur
 .B IFF_BROADCAST
 de l'interface.
 .TP
-.B "[-]pointopoint [adr]"
+.B "[\-]pointopoint [adr]"
 Ce mot cl valide le mode
 .B point--point
 d'une interface, signifiant qu'il existe un lien direct entre 2 machines,
@@ -196,7 +196,7 @@ comptabilit
 Mme si les adresses appletalk DDP et IPX peuvent tre affiches,
 elles ne peuvent tre modifies avec cette commande.
 .SH VOIR AUSSI
-route(8), netstat(8), arp(8), rarp(8), ipchains(8)
+route(8), netstat(8), arp(8), rarp(8), ipchains(8), iptables(8), ifup(8), interfaces(5).
 .SH AUTHORS
 Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 .br
diff --git a/man/fr_FR/netstat.8 b/man/fr_FR/netstat.8
index bf16bc6..93233e3 100644
--- a/man/fr_FR/netstat.8
+++ b/man/fr_FR/netstat.8
@@ -8,7 +8,7 @@
 .\" Modified: Tuan Hoang tuan@optimus.mitre.org 
 .\"
 .\"
-.TH NETSTAT 8 "25 Fv 1999" "net-tools" "Linux Programmer's Manual"
+.TH NETSTAT 8 "2007-12-02" "net\-tools" "Linux Programmer's Manual"
 
 .SH NAME
 netstat \- Affiche les connexions rseau, les tables de routage, les
@@ -76,17 +76,17 @@ ouvertes. C'est l'option par d
 d'adresses, les sockets actives de toutes les familles d'adresses seront
 affiches.
 Avec le paramtre
-.B -e
+.B \-e
 vous obtenez quelques informations supplmentaires (userid). Avec le paramtre
-.B -v
+.B \-v
 vous pouvez demander  netstat de signaler des familles d'adresses connues
 non supportes par le noyau. Le paramtre
-.B -o
+.B \-o
 affiche des informations supplmentaires sur les timers rseau. En donnant
 le paramtre
-.B -p
+.B \-p
 vous verrez le PID et le nom du processus  qui appartient la socket. Le paramtre
-.B -a
+.B \-a
 affiche toutes les sockets, y compris les sockets d'coute des serveurs. La famille
 d'adresses
 .B inet
@@ -97,30 +97,30 @@ Avec le param
 .BR \-r ", " \-\-route
 vous pouvez visualiser les tables de routage dans le mme format qu'avec la
 commande
-.B "route -e" 
+.B "route \-e" 
 .
-.B "netstat -er" 
+.B "netstat \-er" 
 utilisera le format de la commande
 .BR route .
 Veuillez consulter
 .BR route (8)
 pour plus de dtails.
 
-.SS "\-i, \-\-interface \fIiface\fI"
+.SS "\-i, \-\-interfaces \fIiface\fI"
 Si vous utilisez l'option
-.BR -i ", " --interfaces
+.BR \-i ", " \-\-interfaces
 , une table de toutes (ou de l'interface
 .IR iface 
 spcifie) les interfaces rseau sera affiche. Le format de sortie est le
 mme que celui de la commande
-.B "ifconfig -e"
+.B "ifconfig \-e"
 , et est dcrit dans
 .BR ifconfig (8).
-.B "netstat -ei"
+.B "netstat \-ei"
 affiche une table ou une seule entre d'interface comme la commande 
-.B ifconfig
-. Avec le paramtre
-.B -a
+.BR ifconfig .
+Avec le paramtre
+.B \-a
 , vous pouvez inclure les interfaces qui ne sont pas configures (c.a.d qui
 n'ont pas l'indicateur
 .BR U = UP
@@ -129,7 +129,7 @@ arm
 .SS "\-M, \-\-masquerade"
 
 Permet de voir les sessions ayant de l'IP-masquerade. Avec le paramtre
-.B -e 
+.B \-e 
 vous pouvez inclure quelques informations concernant les numros de
 squence et les deltas causs par des rcritures de donnes sur des
 sessions FTP (commande PORT). Le support de l'IP-Masquerade est utilis
@@ -197,24 +197,24 @@ l'interrompiez.
 .SS "Proto" 
 Le protocole (TCP, UDP, RAW) utilis par la socket. 
 
-.SS "Recv-Q"
+.SS "Recv\-Q"
 Le nombre d'octets non encore lus par le programme utilisateur connect
  cette socket.
 
-.SS "Send-Q"
+.SS "Send\-Q"
 Le nombre d'octets non encore acquitts par l'hte distant.
 
 .SS "Local Address (Adresse locale)" 
 L'adresse locale (nom d'hte local) et numro de port de la
 socket. Sauf si l'option
-.B -n
+.B \-n
 est donne, l'adresse de la prise est traduite en nom d'hte,
 et le numro de port est traduit en nom de service correspondant.
 
 .SS "Foreign Address (Adresse distante)"
 L'adresse distante (nom d'hte distant) et le numro de port de
 la prise. Comme pour l'adresse locale et le numro de port, l'option
-.B -n
+.B \-n
 invalide la traduction du nom d'hte et de service.
 
 .SS "State (Etat)"
@@ -249,7 +249,7 @@ La socket attend le traitement de tous les paquets encore sur le r
 avant d'entreprendre la fermeture.
 .TP
 .I
-CLOSED
+CLOSE
 La socket n'est pas utilise.
 .TP
 .I
@@ -264,7 +264,7 @@ Le distant termine, et la socket est ferm
 LISTEN
 La socket est  l'coute de connexions entrantes. Ces sockets ne sont
 affiches que si le paramtre
-.BR -a , --listening
+.BR \-a , \-\-listening
 est fourni.
 .TP
 .I
@@ -282,7 +282,7 @@ Le nom d'utilisateur ou l'UID du propri
 .SS "PID/Program name (PID/Nom de Programme)"
 Le PID et le nom du programme (spars par un slash) propritaire de la
 socket. Le paramtre
-.B -p
+.B \-p
 active l'affichage de cette colonne. Vous devez avoir les droits de
 .B root
 puisque vous devez avoir les droits d'accs aux processus pour visualiser
@@ -357,7 +357,7 @@ La socket n'est pas allou
 LISTENING
 La socket est  l'coute de demandes de connexions. Ces sockets ne sont
 affiches que si le paramtre
-.BR -a , --listening
+.BR \-a , \-\-listening
 est fourni.
 .TP
 .I
@@ -406,11 +406,10 @@ Affiche le chemin correspondant 
 
 .PP
 .SH NOTES
-Depuis la version 2.2 du noyau, netstat -i n'affiche plus les statistiques
+Depuis la version 2.2 du noyau, netstat \-i n'affiche plus les statistiques
 des interfaces alias. Pour obtenir les compteurs par interface alias, vous
 devez dfinir des rgles spcifiques  l'aide de la commande
-.BR ipchains(8) 
-.  
+.BR ipchains (8).
 
 .SH FICHIERS
 .ta
@@ -483,18 +482,18 @@ si une socket change d'
 Ceci est peut probable.
 .br
 Le paramtre
-.B netstat -i
+.B netstat \-i
 est dcrit tel qu'il fonctionnera lorsque le code de la version BETA du
-paquetage net-tools aura t nettoy.
+paquetage net\-tools aura t nettoy.
 
 .PP
 .SH AUTEURS
 L'interface utilisateur de netstat a t dveloppe par
-Fred Baumgarten <dc6iq@insu1.etec.uni-karlsruhe.de>. Les pages du
+Fred Baumgarten <dc6iq@insu1.etec.uni\-karlsruhe.de>. Les pages du
 manuel essentiellement crites par Matt Welsh
 <mdw@tc.cornell.edu>. Mis  jour par Alan Cox <Alan.Cox@linux.org>.
 .br
-La page de manuel et la commande incluse dans le paquetage net-tools
+La page de manuel et la commande incluse dans le paquetage net\-tools
 a t totallement rcrite par Bernd Eckenfels 
 <ecki@linux.de>.
 .SH TRADUCTION
diff --git a/man/fr_FR/rarp.8 b/man/fr_FR/rarp.8
index 73e9328..ea9d609 100644
--- a/man/fr_FR/rarp.8
+++ b/man/fr_FR/rarp.8
@@ -1,14 +1,14 @@
-.TH RARP 8 "4 Aot 1997" "net-tools" "Linux Programmer's Manual"
+.TH RARP 8 "4 Aot 1997" "net\-tools" "Linux Programmer's Manual"
 .SH NOM
 rarp \- manipule la table systme RARP
 .SH SYNOPSIS
-.B "rarp [-V] [--version] [-h] [--help]"
+.B "rarp [\-V] [\-\-version] [\-h] [\-\-help]"
 .br
-.B "rarp -a"
+.B "rarp \-a"
 .br
-.B "rarp [-v] -d nom_d_hote ..."
+.B "rarp [\-v] \-d nom_d_hote ..."
 .br
-.B "rarp [-v] [-t type] -s nom_d_hote adr_materiel"
+.B "rarp [\-v] [\-t type] \-s nom_d_hote adr_materiel"
 .SH DESCRIPTION
 .B Rarp
 manipule la table RARP du noyau de diffrentes faons.  Les options de base
@@ -55,8 +55,8 @@ Supprime toutes les entr
 Cre manuellement une correspondance d'adresses RARP pour l'hte
 .B nom_d_hte
 avec l'adresse matrielle
-.B adr_materielle
-. Le format de l'adresse matrielle est dpendant du matriel,
+.BR adr_materielle .
+Le format de l'adresse matrielle est dpendant du matriel,
 mais pour la plupart on peut considrer que la prsentation classique
 peut tre utilise.  Pour la classe Ethernet, c'est 6 octets en hexadcimal,
 spars par des double-points.
diff --git a/man/fr_FR/route.8 b/man/fr_FR/route.8
index 9109e8d..9cc63f0 100644
--- a/man/fr_FR/route.8
+++ b/man/fr_FR/route.8
@@ -1,4 +1,4 @@
-.TH ROUTE 8 "8 Aot 1997" "net-tools" "Linux Programmer's Manual"
+.TH ROUTE 8 "2007-12-02" "net\-tools" "Linux Programmer's Manual"
 .SH NAME
 route \- affiche / manipule la table de routage IP
 .SH SYNOPSIS
@@ -51,7 +51,7 @@ If]
 .RB [ \-V ] 
 .RB [ \-\-version ]
 .RB [ \-h ]
-.RB [ \--help ]
+.RB [ \-\-help ]
 .SH DESCRIPTION
 .B Route
 manipule la table de routage IP du noyau.  Son utilisation premire
@@ -77,7 +77,7 @@ savoir pourquoi la route vers votre serveur de nom a disparu.
 .TP
 .B \-e
 utilise
-.BR netstat (8)-format
+.BR netstat (8)\-format
 pour l'affichage de la table de routage.
 .B \-ee 
 Gnre une trs longue ligne avec tous les paramtres  partir de la table
@@ -90,13 +90,13 @@ la
 est un rseau.
 
 .TP
-.B -host
+.B \-host
 la
 .B cible 
 est un hte.
 
 .TP 
-.B -F
+.B \-F
 affiche la table de routage FIB du noyau. L'organisation peut tre change avec
 .B \-e
 et
@@ -104,7 +104,7 @@ et
 .
 
 .TP 
-.B -C
+.B \-C
 affiche le cache de routage du noyau. 
 
 .TP
@@ -188,25 +188,25 @@ modificateurs de route (metric - netmask - gw - dev) n'a pas d'importance.
 
 .SH EXEMPLES
 .TP
-.B route add -net 127.0.0.0
+.B route add \-net 127.0.0.0
 ajoute l'entre loopback normale, en utilisant le masque 255.0.0.0 (rseau
 de classe A, selon l'adresse de destination) et associe avec l'interface 
 "lo" (en supposant que ce priphrique a t correctement configur avec
 .BR ifconfig (8)). 
 
 .TP 
-.B route add -net 192.56.76.0 netmask 255.255.255.0 dev eth0
+.B route add \-net 192.56.76.0 netmask 255.255.255.0 dev eth0
 ajoute une route vers le rseau 192.56.76.x via 
 "eth0". Le masque de classe C n'est pas vraiment ncessaire ici car
 192.* est une adresse IP de classe C. Le mot "dev" peut tre omis. 
 
 .TP
-.B route add default gw mango-gw
+.B route add default gw mango\-gw
 ajoute une route par dfaut (qui sera utilise si aucune autre route ne
 convient). Tous les paquets empreintant cette route passeront par
-"mango-gw". Le priphrique qui sera effectivement utilis pour cette route
-dpend de la faon dont on atteint "mango-gw" - la route statique vers
-"mango-gw" devra tre pralablement configure. 
+"mango\-gw". Le priphrique qui sera effectivement utilis pour cette route
+dpend de la faon dont on atteint "mango\-gw" - la route statique vers
+"mango\-gw" devra tre pralablement configure. 
 
 .TP
 .B route add ipx4 sl0
@@ -214,7 +214,7 @@ ajoute une route vers l'h
 "ipx4" est l'hte SLIP).
 
 .TP
-.B route add -net 192.57.66.0 netmask 255.255.255.0 gw ipx4
+.B route add \-net 192.57.66.0 netmask 255.255.255.0 gw ipx4
 Cette commande route le rseau "192.57.66.x" par l'ancienne route vers l'interface SLIP.
 
 .TP
@@ -285,8 +285,8 @@ de routage.
 Nombre de rfrences  cette route. (Pas utilis dans le noyau Linux.)
 .TP
 .B Use
-Count of lookups for the route.  Depending on the use of -F and -C this will
-be either route cache misses (-F) or hits (-C).
+Count of lookups for the route.  Depending on the use of \-F and \-C this will
+be either route cache misses (\-F) or hits (\-C).
 .TP
 .B Iface
 Interface vers laquelle les paquets empruntant cette route seront envoys.
@@ -330,6 +330,6 @@ Linus Torvalds pour pl15. Alan Cox a ajout
 la gestion des fentres et MSS pour Linux 1.1.22. Le support de irtt 
 et la fusion avec netstat ont t raliss par Bernd Eckenfels.
 .SH AUTEUR
-Maintenu par Phil Blundell <Philip.Blundell@pobox.com>.
+Maintenu par Phil Blundell <Philip.Blundell@pobox.com> et Bernd Eckenfels <net-tools@lina.inka.de>.
 .SH TRADUCTION
-Jean-Michel VANSTEENE (vanstee@worldnet.fr)
+Jean-Michel VANSTEENE <vanstee@worldnet.fr>
diff --git a/man/fr_FR/slattach.8 b/man/fr_FR/slattach.8
index 512d514..10a20f7 100644
--- a/man/fr_FR/slattach.8
+++ b/man/fr_FR/slattach.8
@@ -2,7 +2,7 @@
 .SH NOM
 slattach \- attache une interface rseau  une ligne srie
 .SH SYNOPSIS
-.B "slattach [-dehlLmnqv] [-c commande] [-p proto] [-s vitesse] [tty]"
+.B "slattach [\-dehlLmnqv] [\-c commande] [\-p proto] [\-s vitesse] [tty]"
 .br
 .SH DESCRIPTION
 .B Slattach
@@ -12,46 +12,46 @@ ceci vous permettant de l'utiliser pour des liaisons point-
 vers d'autres systmes.
 .SH OPTIONS
 .TP
-.B "[-c commande]"
+.B "[\-c commande]"
 Excute
 .B `commande'
 lorsque la ligne est suspendue. Ceci peut tre utilis pour lancer
 des scripts ou rtablir des connexions quand un lien tombe.
 .TP
-.B "[-d]"
+.B "[\-d]"
 Valide le dbogage.  Utile pour dterminer pourquoi une configuration
 ne fonctionne pas.
 .TP
-.B "[-h]"
+.B "[\-h]"
 Termine lorsque la porteuse est perdue. Ceci fonctionne  la fois sur
 les priphriques /dev/tty et /dev/cua en contrlant directement
 l'tat de la porteuse toutes les 15 secondes.
 .TP
-.B "[-v]"
+.B "[\-v]"
 Valide le mode verbeux.  Utile pour les shell scripts.
 .TP
-.B "[-q]"
+.B "[\-q]"
 Opre en mode silencieux - pas de messages du tout.
 .TP
-.B "[-l]"
+.B "[\-l]"
 Cre un fichier de vrouillage pour le priphrique comme
 pour UUCP dans /var/lock.
 .TP
-.B "[-n]"
+.B "[\-n]"
 Equivalent  la commande "mesg n".
 .TP
-.B "[-m]"
+.B "[\-m]"
 \fBn'\fPinitialise \fBpas\fP la ligne en mode raw 8 bits.
 .TP
-.B "[-e]"
+.B "[\-e]"
 Termine correctement aprs l'initialisation du priphrique,
 au lieu d'attendre que la ligne soit suspendue.
 .TP
-.B "[-L]"
+.B "[\-L]"
 Valide les oprations 3 lignes. Le terminal est mis en mode CLOCAL, 
 la surveillance de porteuse est invalide.
 .TP
-.B "[-p proto]"
+.B "[\-p proto]"
 Dfinit le protocole spcifique  utiliser sur la ligne.
 La valeur par dfaut est 
 .B "cslip"
@@ -75,7 +75,7 @@ pour 
 .B axattach
 doit tre utilis.
 .TP
-.B "[-s vitesse]"
+.B "[\-s vitesse]"
 Dfinit la vitesse de la ligne, diffrente de la valeur par dfaut.
 .PP
 Si aucun argument n'est donn, la ligne courante du terminal
diff --git a/man/pt_BR/arp.8 b/man/pt_BR/arp.8
index 41c8fd6..6034934 100644
--- a/man/pt_BR/arp.8
+++ b/man/pt_BR/arp.8
@@ -1,12 +1,12 @@
-.TH ARP 8 "22 de junho de 1996" "net-tools" "Manual do Programador Linux"
+.TH ARP 8 "22 de junho de 1996" "net\-tools" "Manual do Programador Linux"
 .SH NOME
 arp \- manipula o cache ARP do sistema
 .SH SINOPSE
 .B arp 
 .RB [ \-vn ] 
 .RB [ "\-H tipo" ] 
-.RB [ "-i if" ] 
-.B -a 
+.RB [ "\-i if" ] 
+.B \-a 
 .RB [ mquina ]
 .PP
 .B arp 
@@ -20,7 +20,7 @@ arp \- manipula o cache ARP do sistema
 .RB [ \-v ] 
 .RB [ "\-H tipo" ] 
 .RB [ "\-i if" ] 
-.B -s mquina endereo_hardware
+.B \-s mquina endereo_hardware
 .RB [ temp ] 
 .RB [ nopub ]
 .PP
@@ -28,7 +28,7 @@ arp \- manipula o cache ARP do sistema
 .RB [ \-v ] 
 .RB [ "\-H tipo" ] 
 .RB [ "\-i if" ] 
-.B -s mquina endereo_hardware
+.B \-s mquina endereo_hardware
 .RB [ "netmask nm" ] 
 .B pub
 .PP
@@ -36,15 +36,15 @@ arp \- manipula o cache ARP do sistema
 .RB [ \-v ] 
 .RB [ "\-H tipo" ] 
 .RB [ "\-i if" ] 
-.B -Ds mquina ifa
+.B \-Ds mquina ifa
 .RB [ "netmask nm" ] 
 .B pub
 .PP
 .B arp 
 .RB [ \-vnD ]
 .RB [ "\-H tipo" ] 
-.RB [ "-i if" ]
-.B -f arquivo
+.RB [ "\-i if" ]
+.B \-f arquivo
 
 .SH DESCRIO
 .B arp
@@ -62,7 +62,7 @@ Mostra ao usu
 mostra endereos numricos, ao invs de tentar determinar os nomes simblicos da
 mquina, porta e usurio.
 .TP
-.B "\-H type, \-\-hw-type type"
+.B "\-H type, \-\-hw\-type type"
 Quando configurando ou lendo o cache ARP, este parmetro opcional informa ao
 .B arp
 que classe de entradas devem ser verificadas. O valor padro deste parmetro 
@@ -96,7 +96,7 @@ ou
 para decidir se uma entrada pblica ou privada deve ser removida. Se voc
 no informar uma destas flags as duas entradas sero removidas.
 .TP
-.B "\-D, \-\-use-device"
+.B "\-D, \-\-use\-device"
 Usa o endereo de hardware da interface 
 .BR ifa
 .TP
@@ -170,7 +170,7 @@ e entradas publicadas tem uma flag
 .I /etc/ethers
 .SH AUTOR
 Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org> com muitas melhorias
-feitas pelo mantenedor do net-tools, Bernd Eckenfels <net-tools@lina.inka.de>.
+feitas pelo mantenedor do net\-tools, Bernd Eckenfels <net\-tools@lina.inka.de>.
 Traduo para a lngua portuguesa feita por
 Arnaldo Carvalho de Melo <acme@conectiva.com.br> em 11/abril/1998.
 Revisado por 
diff --git a/man/pt_BR/hostname.1 b/man/pt_BR/hostname.1
index fe00879..b1a25f2 100644
--- a/man/pt_BR/hostname.1
+++ b/man/pt_BR/hostname.1
@@ -1,4 +1,4 @@
-.TH HOSTNAME 1 "28 de janeiro de 1996" "net-tools" "Manual do Programador Linux"
+.TH HOSTNAME 1 "28 de janeiro de 1996" "net\-tools" "Manual do Programador Linux"
 
 .SH NOME
 hostname \- mostra ou configura o nome da mquina 
@@ -21,7 +21,7 @@ ypdomainname \- mostra ou configura o nome do dom
 .RB [ \-f ]
 .RB [ \-\-fqdn ]
 .RB [ \-i ]
-.RB [ \-\-ip-address ]
+.RB [ \-\-ip\-address ]
 .RB [ \-\-long ]
 .RB [ \-s ]
 .RB [ \-\-short ]
@@ -161,7 +161,7 @@ do dom
 .I "\-h, \-\-help"
 Mostra uma mensagem sobre como utilizar o comando e termina.
 .TP
-.I "\-i, \-\-ip-address"
+.I "\-i, \-\-ip\-address"
 Mostra o(s) endereo(s) IP da mquina.
 .TP
 .I "\-s, \-\-short"
@@ -180,9 +180,9 @@ Mostra o nome do dom
 .SH ARQUIVOS
 .B /etc/hosts
 .SH AUTOR
-Peter Tobias, <tobias@et-inf.fho-emden.de>
+Peter Tobias, <tobias@et\-inf.fho\-emden.de>
 .BR
-Bernd Eckenfels, <net-tools@lina.inka.de> (NIS e pgina man).
+Bernd Eckenfels, <net\-tools@lina.inka.de> (NIS e pgina man).
 .BR
 Arnaldo Carvalho de Melo, <acme@conectiva.com.br> Traduo para a lngua
 portuguesa.
diff --git a/man/pt_BR/ifconfig.8 b/man/pt_BR/ifconfig.8
index 0a97683..2d1e02c 100644
--- a/man/pt_BR/ifconfig.8
+++ b/man/pt_BR/ifconfig.8
@@ -1,4 +1,4 @@
-.TH IFCONFIG 8 "10 de fevereiro de 1996" "net-tools" "Manual do Programador Linux"
+.TH IFCONFIG 8 "2007-12-02" "net\-tools" "Manual do Programador Linux"
 .SH NOME
 ifconfig \- configura uma interface de rede
 .SH SINOPSE
@@ -61,7 +61,7 @@ o sinal de menos (\-) estiver presente a op
 .TP
 .B "[\-]trailers" 
 Habilita ou desabilita o uso de trailer em frames Ethernet. No 
-utilizada na implementao atual do pacote net-tools.
+utilizada na implementao atual do pacote net\-tools.
 .TP
 .B "[\-]allmulti" 
 Habilita ou desabilita o modo
@@ -97,7 +97,7 @@ uso de sub-redes.
 Configura a linha de interrupo (IRQ) usada por este dispositivo. Muitos
 dispositivos no suportam configurao dinmica de IRQ.
 .TP
-.B "[-]broadcast [endereo]"
+.B "[\-]broadcast [endereo]"
 Se o argumento endereo for informado, configura o endereo de protocolo
 broadcast para esta interface. De outra forma ele somente configura a flag
 .B IFF_BROADCAST
@@ -105,7 +105,7 @@ da interface.  Se a palavra-chave for precedida por um sinal de menos
 .B (-)
 , ento a flag  removida.
 .TP
-.B "[-]pointopoint [endereo]"
+.B "[\-]pointopoint [endereo]"
 Esta palavra-chave habilita o modo
 .B ponto-a-ponto
 da interface, significando que ela  um link direto entre duas mquinas
@@ -169,7 +169,7 @@ endere
 Os endereos appletalk DDP e IPX sero mostrados, mas no podem ser alterados
 com este comando.
 .SH VEJA TAMBM
-route(8), netstat(8), arp(8), rarp(8), ipchains(8)
+route(8), netstat(8), arp(8), rarp(8), ipchains(8), iptables(8), ifup(8), interfaces(5).
 .SH AUTORES
 Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
 Alan Cox, <Alan.Cox@linux.org>
diff --git a/man/pt_BR/netstat.8 b/man/pt_BR/netstat.8
index b9b359a..1365b59 100644
--- a/man/pt_BR/netstat.8
+++ b/man/pt_BR/netstat.8
@@ -8,7 +8,7 @@
 .\" Traduzido para portugus por Arnaldo Carvalho de Melo <acme@conectiva.com.br>
 .\" Revisado por Jorge Luiz Godoy Filho <jorge@bestway.com.br>
 .\"
-.TH NETSTAT 8 "19 de maio de 1997" "net-tools" "Manual do Programador Linux"
+.TH NETSTAT 8 "2007-12-02" "net\-tools" "Manual do Programador Linux"
 
 .SH NOME
 netstat \- Mostra conexes de rede, tabelas de roteamento, estatsticas de interface e conexes
@@ -72,14 +72,14 @@ Voc
 abertos. Esta  a operao padro: se voc no especificar nenhuma
 famlia de endereos, os sockets ativos de todas as famlias de endereos
 configuradas sero mostrados. Com
-.B -e
+.B \-e
 voc obter informaes adicionais (userid). Com a chave
-.B -v
+.B \-v
 voc poder fazer com que o netstat reclame sobre famlias de endereos
 conhecidas que no sejam suportadas pelo kernel. A opo
-.B -o
+.B \-o
 mostra algumas informaes adicionais sobre temporizadores de rede.
-.B -a
+.B \-a
 mostra todos os sockets, incluindo sockets de servidores. A famlia de
 endereos
 .B inet
@@ -89,28 +89,28 @@ mostrar
 Com a opo
 .BR \-r ", " \-\-route
 voc obter as tabelas de roteamento do kernel no mesmo formato usado por
-.BR "route -e" .
-.B "netstat -er" 
+.BR "route \-e" .
+.B "netstat \-er" 
 usar o formato de apresentao do comando
 .BR route .
 Por favor veja
 .BR route (8)
 para maiores detalhes.
 
-.SS "\-i, \-\-interface \fIiface\fI"
+.SS "\-i, \-\-interfaces \fIiface\fI"
 Se voc usar a opo
-.BR -i ", " --interfaces
+.BR \-i ", " \-\-interfaces
 , uma tabela de todas (ou da
 .IR iface
 especificada) as interfaces de rede ser mostrada. A sada usa o formato
-.B "ifconfig -e"
+.B "ifconfig \-e"
 , e  descrita em
 .BR ifconfig (8).
-.B "netstat -ei" 
+.B "netstat \-ei" 
 mostrar uma tabela ou uma entrada de interface como
 .B ifconfig
 mostra. Com a chave
-.B -a
+.B \-a
 , voc pode incluir interfaces que no estejam configuradas (i.e. no tem
 a flag 
 .BR U = UP
@@ -119,7 +119,7 @@ configurada).
 .SS "\-M, \-\-masquerade"
 
 Uma lista de todas as sesses mascaradas tambm pode ser vista. Com a chave
-.B -e 
+.B \-e 
 voc pode incluir mais algumas informaes sobre numerao sequencial e deltas
 , causados por reescritas de dados em sesses FTP (comando PORT).
 O suporte a mascaramento  usado para esconder mquinas em endereos de
@@ -179,23 +179,23 @@ voc
 .SS "Proto" 
 O protocolo (tcp, udp, raw) usado pelo socket.
 
-.SS "Recv-Q"
+.SS "Recv\-Q"
 O contador de bytes no copiados pelo programa conectado a este socket.
 
-.SS "Send-Q"
+.SS "Send\-Q"
 O contador de bytes no confirmados pela mquina remota.
 
 .SS "Endereo Local" 
 O endereo local (nome da mquina local) e o numero da porta do socket. A menos
 que a chave
-.B -n
+.B \-n
 seja especificada o endereo do socket ser resolvido para seu nome de mquina
 cannico e o nmero da porta ser traduzido para o servio correspondente.
 
 .SS "Endereo Remoto"
 O endereo remoto (nome da mquina remota) e o nmero da porta do socket. Como
 com o endereo local, a chave
-.B -n
+.B \-n
 desliga a resoluo do nome da mquina e do servio.
 
 .SS "Estado"
@@ -245,7 +245,7 @@ confirma
 OUVINDO
 O socket est ouvindo por conexes. Estes socket so somente mostrados se
 a chave
-.BR -a , --listening
+.BR \-a , \-\-listening
 for especificada.
 .TP
 .I
@@ -329,7 +329,7 @@ Este socket n
 LISTENING
 O socket est aguardando por uma solicitao de conexo. So mostrados
 apenas se as opes
-.BR -a , --listening
+.BR \-a , \-\-listening
 forem selecionadas.
 .TP
 .I
@@ -372,7 +372,7 @@ Mostra o caminho (path) do processo do qual est
 
 .PP
 .SH NOTAS
-Desde o kernel 2.2 o netstat -i no mostra estatsticas para apelidos (aliases)
+Desde o kernel 2.2 o netstat \-i no mostra estatsticas para apelidos (aliases)
 de interfaces. Para obter contadores por apelido de interface voc precisa
 configurar regras explcitas usando o comando
 +.BR ipchains(8)
@@ -447,20 +447,20 @@ Ocasionalmente informa
 enquanto  visualizado. Isso  incomum.
 .br
 As opes descritas para
-.B netstat -i
+.B netstat \-i
 foram descritas como devero funcionar aps alguma limpeza da liberao
-BETA do pacote net-tools.
+BETA do pacote net\-tools.
 
 .PP
 .SH AUTORES
 A interface com o usurio foi escrita por Fred Baumgarten
-<dc6iq@insu1.etec.uni-karlsruhe.de> a pgina do manual basicamente
+<dc6iq@insu1.etec.uni\-karlsruhe.de> a pgina do manual basicamente
 por Matt Welsh <mdw@tc.cornell.edu>. Foi atualizada por
 Alan Cox <Alan.Cox@linux.org> mas poderia ter sido feita com um pouco
 mais de trabalho.
 .BR
 .LP
-A pgina do manual e os comandos includos no pacote net-tools
+A pgina do manual e os comandos includos no pacote net\-tools
 foram totalmente reescritos desde Bernd Eckenfels
 <ecki@linux.de>.
 .BR
diff --git a/man/pt_BR/rarp.8 b/man/pt_BR/rarp.8
index de31931..d981f15 100644
--- a/man/pt_BR/rarp.8
+++ b/man/pt_BR/rarp.8
@@ -1,12 +1,12 @@
-.TH RARP 8 "10 de fevereiro de 1996" "net-tools" "Manual do Programador Linux"
+.TH RARP 8 "10 de fevereiro de 1996" "net\-tools" "Manual do Programador Linux"
 .SH NOME
 rarp \- manipula a tabela RARP do sistema
 .SH SINOPSE
-.B "rarp [-v] [-t tipo] -a [mquina]"
+.B "rarp [\-v] [\-t tipo] \-a [mquina]"
 .br
-.B "rarp [-v] -d mquina ..."
+.B "rarp [\-v] \-d mquina ..."
 .br
-.B "rarp [-v] [-t tipo] -s mquina endereo_hardware"
+.B "rarp [\-v] [\-t tipo] \-s mquina endereo_hardware"
 .SH DESCRIO
 .B Rarp
 manipula as tabelas RARP do kernel de varias formas. As opes principais
@@ -50,8 +50,8 @@ m
 Cria um mapeamento de endereos RARP para a mquina
 .B mquina
 com endereo de hardware configurado para
-.B endereo_hardware
-.  O formato do endereo de hardware depende da classe do hardware, mas
+.B endereo_hardware.
+O formato do endereo de hardware depende da classe do hardware, mas
 para a maioria das classes voc pode assumir que a apresentao usual pode
 ser usada.  Para a classe Ethernet, so 6 bytes em hexadecimal, separados
 por dois pontos (:).
diff --git a/man/pt_BR/route.8 b/man/pt_BR/route.8
index c440974..85b8d2f 100644
--- a/man/pt_BR/route.8
+++ b/man/pt_BR/route.8
@@ -1,4 +1,4 @@
-.TH ROUTE 8 "27 Jan 1996" "net-tools" "Manual do Programador Linux"
+.TH ROUTE 8 "2007-12-02" "net\-tools" "Manual do Programador Linux"
 .SH NOME
 route \- mostra / manipula a tabela de roteamento IP
 .SH SINOPSE
@@ -47,7 +47,7 @@ If]
 .RB [ \-V ] 
 .RB [ \-\-version ]
 .RB [ \-h ]
-.RB [ \--help ]
+.RB [ \-\-help ]
 .SH DESCRICAO
 .B Route
 manipula a tabela de roteamento IP do kernel. Seu principal uso 
@@ -186,7 +186,7 @@ modificadores do route (metric - netmask - gw - dev) n
 
 .SH EXEMPLOS
 .TP
-.B route add -net 127.0.0.0
+.B route add \-net 127.0.0.0
 Adiciona a entrada para a interface loopback normal, usando mascara igual
 a 255.0.0.0 (rede classe A, determinada a partir do endereo de destino),
 associada ao dispositivo "lo" (assumindo que este dispositivo tenha sido
@@ -194,17 +194,17 @@ previamente configurado com o
 .BR ifconfig (8)). 
 
 .TP 
-.B route add -net 192.56.76.0 netmask 255.255.255.0 dev eth0
+.B route add \-net 192.56.76.0 netmask 255.255.255.0 dev eth0
 Adiciona uma rota para a rede 192.56.76.x atravs da interface "eth0". O 
 modificador de mascara classe C no  realmente necessrio aqui por que
 192.*  um endereo IP de classe C. A palavra "dev" pode ser omitida aqui.
 
 .TP
-.B route add default gw mango-gw
+.B route add default gw mango\-gw
 Adiciona uma rota default (que ser usada se nenhuma outra rota for encontrada).
-Todos os pacotes que usarem esta rota sero passados para a mquina "mango-gw".
+Todos os pacotes que usarem esta rota sero passados para a mquina "mango\-gw".
 O dispositivo que ser utilizado para esta rota depende de como  possvel
-alcanar "mango-gw" - a rota esttica para "mango-gw" ter que ser configurada
+alcanar "mango\-gw" - a rota esttica para "mango\-gw" ter que ser configurada
 previamente.
 
 .TP
@@ -213,12 +213,12 @@ Adiciona uma rota para a m
 que "ipx4"  a mquina SLIP).
 
 .TP
-.B route add -net 192.57.66.0 netmask 255.255.255.0 gw ipx4
+.B route add \-net 192.57.66.0 netmask 255.255.255.0 gw ipx4
 Este comando adiciona a rede "192.57.66.x" para ser alcanada atravs da
 rota anterior atravs da interface SLIP.
 
 .TP
-.B route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0
+.B route add \-net 224.0.0.0 netmask 240.0.0.0 dev eth0
 Isto  bem obscura, documentada para que as pessoas saibam como us-la. 
 Configura para que todas as rotas IP classe D (multicast) vo atravs da
 interface "eth0". Esta  a linha de configurao normal a ser usada com
@@ -239,8 +239,8 @@ A rede ou m
 A mquina roteador ou '*' se nenhuma estiver configurada.
 .TP
 .B Mascara Genrica
-A mascara para a rede destino. '255.255.255.255' para uma mquina de destino,
-'0.0.0.0' para a rota
+A mascara para a rede destino. '255.255.255.255' para uma mquina de
+destino, '0.0.0.0' para a rota
 .B default
 .
 .TP
@@ -321,7 +321,7 @@ para o linux foi originalmente escrito por Fred N. van Kempen,
 Linus Torvalds para a verso pl15. Alan Cox adicionou as opes para
 mss e window no kernel 1.1.22. O suporte a irtt (compartilhado com o
 netstat) foi feito por Bernd Eckenfels.
+.SH AUTHOR
+Currently maintained by Phil Blundell <Philip.Blundell@pobox.com> and Bernd Eckenfels <net-tools@lina.inka.de>.
 .SH TRADUO
 Arnaldo Carvalho de Melo <acme@conectiva.com.br> - 13/04/1998
-.SH BUGS
-nenhum :)
diff --git a/mii-tool.c b/mii-tool.c
index ef2d48a..d812e8a 100644
--- a/mii-tool.c
+++ b/mii-tool.c
@@ -29,8 +29,7 @@
 	http://www.national.com/pf/DP/DP83840.html
 */
 
-static char version[] =
-"mii-tool.c 1.9 2000/04/28 00:56:08 (David Hinds)\n";
+static char Version[] = "$Id: mii-tool.c,v 1.9 2006/09/27 20:59:18 ecki Exp $\n(Author: David Hinds based on Donald Becker's mii-diag)";
 
 #include <unistd.h>
 #include <stdlib.h>
@@ -46,16 +45,19 @@ static char version[] =
 #include <sys/socket.h>
 #include <sys/ioctl.h>
 #include <net/if.h>
+#include <linux/sockios.h>
+
 #ifndef __GLIBC__
 #include <linux/if_arp.h>
 #include <linux/if_ether.h>
 #endif
 #include "mii.h"
+#include "version.h"
 
 #define MAX_ETH		8		/* Maximum # of interfaces */
 
 /* Table of known MII's */
-static struct {
+static const struct {
     u_short	id1, id2;
     char	*name;
 } mii_id[] = {
@@ -74,6 +76,9 @@ static struct {
     { 0x0181, 0x4410, "Quality QS6612" },
     { 0x0282, 0x1c50, "SMSC 83C180" },
     { 0x0300, 0xe540, "TDK 78Q2120" },
+    { 0x0141, 0x0c20, "Yukon 88E1011" },
+    { 0x0141, 0x0cc0, "Yukon-EC 88E1111" },
+    { 0x0141, 0x0c90, "Yukon-2 88E1112" },
 };
 #define NMII (sizeof(mii_id)/sizeof(mii_id[0]))
 
@@ -137,40 +142,48 @@ static void mdio_write(int skfd, int location, int value)
 
 const struct {
     char	*name;
-    u_short	value;
+    u_short	value[2];
 } media[] = {
     /* The order through 100baseT4 matches bits in the BMSR */
-    { "10baseT-HD",	MII_AN_10BASET_HD },
-    { "10baseT-FD",	MII_AN_10BASET_FD },
-    { "100baseTx-HD",	MII_AN_100BASETX_HD },
-    { "100baseTx-FD",	MII_AN_100BASETX_FD },
-    { "100baseT4",	MII_AN_100BASET4 },
-    { "100baseTx",	MII_AN_100BASETX_FD | MII_AN_100BASETX_HD },
-    { "10baseT",	MII_AN_10BASET_FD | MII_AN_10BASET_HD },
+    { "10baseT-HD",	{MII_AN_10BASET_HD} },
+    { "10baseT-FD",	{MII_AN_10BASET_FD} },
+    { "100baseTx-HD",	{MII_AN_100BASETX_HD} },
+    { "100baseTx-FD",	{MII_AN_100BASETX_FD} },
+    { "100baseT4",	{MII_AN_100BASET4} },
+    { "100baseTx",	{MII_AN_100BASETX_FD | MII_AN_100BASETX_HD} },
+    { "10baseT",	{MII_AN_10BASET_FD | MII_AN_10BASET_HD} },
+
+    { "1000baseT-HD",	{0, MII_BMCR2_1000HALF} },
+    { "1000baseT-FD",	{0, MII_BMCR2_1000FULL} },
+    { "1000baseT",	{0, MII_BMCR2_1000HALF|MII_BMCR2_1000FULL} },
 };
 #define NMEDIA (sizeof(media)/sizeof(media[0]))
 	
 /* Parse an argument list of media types */
-static int parse_media(char *arg)
+static int parse_media(char *arg, unsigned *bmcr2)
 {
     int mask, i;
     char *s;
     mask = strtoul(arg, &s, 16);
     if ((*arg != '\0') && (*s == '\0')) {
 	if ((mask & MII_AN_ABILITY_MASK) &&
-	    !(mask & ~MII_AN_ABILITY_MASK))
-	    return mask;
+	    !(mask & ~MII_AN_ABILITY_MASK)) {
+		*bmcr2 = 0;
+		return mask;
+	}
 	goto failed;
-    } else {
-	mask = 0;
-	s = strtok(arg, ", ");
-	do {
+    }
+    mask = 0;
+    *bmcr2 = 0;
+    s = strtok(arg, ", ");
+    do {
 	    for (i = 0; i < NMEDIA; i++)
-		if (strcasecmp(media[i].name, s) == 0) break;
+		if (s && strcasecmp(media[i].name, s) == 0) break;
 	    if (i == NMEDIA) goto failed;
-	    mask |= media[i].value;
-	} while ((s = strtok(NULL, ", ")) != NULL);
-    }
+	    mask |= media[i].value[0];
+	    *bmcr2 |= media[i].value[1];
+    } while ((s = strtok(NULL, ", ")) != NULL);
+
     return mask;
 failed:
     fprintf(stderr, "Invalid media specification '%s'.\n", arg);
@@ -179,11 +192,24 @@ failed:
 
 /*--------------------------------------------------------------------*/
 
-static char *media_list(int mask, int best)
+static const char *media_list(unsigned mask, unsigned mask2, int best)
 {
     static char buf[100];
     int i;
     *buf = '\0';
+
+    if (mask & MII_BMCR_SPEED1000) {
+	if (mask2 & MII_BMCR2_1000HALF) {
+	    strcat(buf, " ");
+	    strcat(buf, "1000baseT-HD");
+	    if (best) goto out;
+	}
+	if (mask2 & MII_BMCR2_1000FULL) {
+	    strcat(buf, " ");
+	    strcat(buf, "1000baseT-FD");
+	    if (best) goto out;
+	}
+    }
     mask >>= 5;
     for (i = 4; i >= 0; i--) {
 	if (mask & (1<<i)) {
@@ -192,6 +218,7 @@ static char *media_list(int mask, int best)
 	    if (best) break;
 	}
     }
+ out:
     if (mask & (1<<5))
 	strcat(buf, " flow-control");
     return buf;
@@ -201,15 +228,15 @@ int show_basic_mii(int sock, int phy_id)
 {
     char buf[100];
     int i, mii_val[32];
-    int bmcr, bmsr, advert, lkpar;
+    unsigned bmcr, bmsr, advert, lkpar, bmcr2, lpa2;
 
     /* Some bits in the BMSR are latched, but we can't rely on being
        the only reader, so only the current values are meaningful */
     mdio_read(sock, MII_BMSR);
-    for (i = 0; i < ((verbose > 1) ? 32 : 8); i++)
+    for (i = 0; i < ((verbose > 1) ? 32 : MII_BASIC_MAX); i++)
 	mii_val[i] = mdio_read(sock, i);
 
-    if (mii_val[MII_BMCR] == 0xffff) {
+    if (mii_val[MII_BMCR] == 0xffff  || mii_val[MII_BMSR] == 0x0000) {
 	fprintf(stderr, "  No MII transceiver present!.\n");
 	return -1;
     }
@@ -217,6 +244,7 @@ int show_basic_mii(int sock, int phy_id)
     /* Descriptive rename. */
     bmcr = mii_val[MII_BMCR]; bmsr = mii_val[MII_BMSR];
     advert = mii_val[MII_ANAR]; lkpar = mii_val[MII_ANLPAR];
+    bmcr2 = mii_val[MII_CTRL1000]; lpa2 = mii_val[MII_STAT1000];
 
     sprintf(buf, "%s: ", ifr.ifr_name);
     if (bmcr & MII_BMCR_AN_ENA) {
@@ -224,7 +252,7 @@ int show_basic_mii(int sock, int phy_id)
 	    if (advert & lkpar) {
 		strcat(buf, (lkpar & MII_AN_ACK) ?
 		       "negotiated" : "no autonegotiation,");
-		strcat(buf, media_list(advert & lkpar, 1));
+		strcat(buf, media_list(advert & lkpar, bmcr2 & lpa2>>2, 1));
 		strcat(buf, ", ");
 	    } else {
 		strcat(buf, "autonegotiation failed, ");
@@ -234,8 +262,10 @@ int show_basic_mii(int sock, int phy_id)
 	}
     } else {
 	sprintf(buf+strlen(buf), "%s Mbit, %s duplex, ",
-	       (bmcr & MII_BMCR_100MBIT) ? "100" : "10",
-	       (bmcr & MII_BMCR_DUPLEX) ? "full" : "half");
+		((bmcr2 & (MII_BMCR2_1000HALF | MII_BMCR2_1000FULL)) & lpa2 >> 2)
+		? "1000"
+		: (bmcr & MII_BMCR_100MBIT) ? "100" : "10",
+		(bmcr & MII_BMCR_DUPLEX) ? "full" : "half");
     }
     strcat(buf, (bmsr & MII_BMSR_LINK_VALID) ? "link ok" : "no link");
 
@@ -296,12 +326,13 @@ int show_basic_mii(int sock, int phy_id)
 	if (bmsr & MII_BMSR_REMOTE_FAULT)
 	    printf("remote fault, ");
 	printf((bmsr & MII_BMSR_LINK_VALID) ? "link ok" : "no link");
-	printf("\n  capabilities:%s", media_list(bmsr >> 6, 0));
-	printf("\n  advertising: %s", media_list(advert, 0));
+	printf("\n  capabilities:%s", media_list(bmsr >> 6, bmcr2, 0));
+	printf("\n  advertising: %s", media_list(advert, lpa2 >> 2, 0));
 	if (lkpar & MII_AN_ABILITY_MASK)
-	    printf("\n  link partner:%s", media_list(lkpar, 0));
+	    printf("\n  link partner:%s", media_list(lkpar, bmcr2, 0));
 	printf("\n");
     }
+    fflush(stdout);
     return 0;
 }
 
@@ -329,7 +360,7 @@ static int do_one_xcvr(int skfd, char *ifname, int maybe)
 	printf("resetting the transceiver...\n");
 	mdio_write(skfd, MII_BMCR, MII_BMCR_RESET);
     }
-    if (nway_advertise) {
+    if (nway_advertise > 0) {
 	mdio_write(skfd, MII_ANAR, nway_advertise | 1);
 	opt_restart = 1;
     }
@@ -379,27 +410,38 @@ static void watch_one_xcvr(int skfd, char *ifname, int index)
 /*--------------------------------------------------------------------*/
 
 const char *usage =
-"usage: %s [-VvRrwl] [-A media,... | -F media] [interface ...]
-       -V, --version               display version information
-       -v, --verbose               more verbose output
-       -R, --reset                 reset MII to poweron state
-       -r, --restart               restart autonegotiation
-       -w, --watch                 monitor for link status changes
-       -l, --log                   with -w, write events to syslog
-       -A, --advertise=media,...   advertise only specified media
-       -F, --force=media           force specified media technology
-media: 100baseT4, 100baseTx-FD, 100baseTx-HD, 10baseT-FD, 10baseT-HD,
-       (to advertise both HD and FD) 100baseTx, 10baseT\n";
+"usage: %s [-VvRrwl] [-A media,... | -F media] [interface ...]\n"
+"       -V, --version               display version information\n"
+"       -v, --verbose               more verbose output\n"
+"       -R, --reset                 reset MII to poweron state\n"
+"       -r, --restart               restart autonegotiation\n"
+"       -w, --watch                 monitor for link status changes\n"
+"       -l, --log                   with -w, write events to syslog\n"
+"       -A, --advertise=media,...   advertise only specified media\n"
+"       -F, --force=media           force specified media technology\n"
+"media: 1000baseTx-HD, 1000baseTx-FD,\n"
+"       100baseT4, 100baseTx-FD, 100baseTx-HD,\n"
+"       10baseT-FD, 10baseT-HD,\n"
+"       (to advertise both HD and FD) 1000baseTx, 100baseTx, 10baseT\n";
+
+
+static void version(void)
+{
+    fprintf(stderr, "%s\n%s\n", Version, RELEASE);
+    exit(5); /* E_VERSION */
+}
+
 
 int main(int argc, char **argv)
 {
     int i, c, ret, errflag = 0;
     char s[6];
+    unsigned ctrl1000 = 0;
     
     while ((c = getopt_long(argc, argv, "A:F:p:lrRvVw?", longopts, 0)) != EOF)
 	switch (c) {
-	case 'A': nway_advertise = parse_media(optarg); break;
-	case 'F': fixed_speed = parse_media(optarg); break;
+	case 'A': nway_advertise = parse_media(optarg, &ctrl1000); break;
+	case 'F': fixed_speed = parse_media(optarg, &ctrl1000); break;
 	case 'p': override_phy = atoi(optarg); break;
 	case 'r': opt_restart++;	break;
 	case 'R': opt_reset++;		break;
@@ -411,6 +453,10 @@ int main(int argc, char **argv)
 	}
     /* Check for a few inappropriate option combinations */
     if (opt_watch) verbose = 0;
+
+    if ((nway_advertise < 0) || (fixed_speed < 0))
+    	return 2;
+
     if (errflag || (fixed_speed & (fixed_speed-1)) ||
 	(fixed_speed && (opt_restart || nway_advertise))) {
 	fprintf(stderr, usage, argv[0]);
@@ -418,7 +464,7 @@ int main(int argc, char **argv)
     }
 
     if (opt_version)
-	printf(version);
+	version();
 
     /* Open a basic socket. */
     if ((skfd = socket(AF_INET, SOCK_DGRAM,0)) < 0) {
@@ -426,6 +472,9 @@ int main(int argc, char **argv)
 	exit(-1);
     }
 
+    if (verbose > 1)
+    	printf("Using SIOCGMIIPHY=0x%x\n", SIOCGMIIPHY);	
+
     /* No remaining args means show all interfaces. */
     if (optind == argc) {
 	ret = 1;
diff --git a/nameif.c b/nameif.c
index 8d79b50..04658c5 100644
--- a/nameif.c
+++ b/nameif.c
@@ -3,7 +3,7 @@
  * Writen 2000 by Andi Kleen.
  * Subject to the Gnu Public License, version 2.  
  * TODO: make it support token ring etc.
- * $Id: nameif.c,v 1.1 2000/10/18 17:26:29 ak Exp $
+ * $Id: nameif.c,v 1.4 2003/09/11 03:46:49 ak Exp $
  */ 
 #ifndef _GNU_SOURCE 
 #define _GNU_SOURCE
@@ -117,7 +117,8 @@ int getmac(char *name, unsigned char *mac)
 }
 
 struct change { 
-	struct change *next,**pprev;
+	struct change *next;
+	int found;
 	char ifname[IFNAMSIZ+1];
 	unsigned char mac[6];
 }; 
@@ -139,10 +140,7 @@ int addchange(char *p, struct change *ch, char *pos)
 			ch->ifname, pos); 
 	if (parsemac(p,ch->mac) < 0) 
 		complain(_("cannot parse MAC `%s' at %s"), p, pos); 
-	if (clist) 
-		clist->pprev = &ch->next;
 	ch->next = clist;
-	ch->pprev = &clist;
 	clist = ch;
 	return 0; 
 }
@@ -177,7 +175,7 @@ void readconf(void)
 		if (*p == '\0')
 			continue; 
 		n = strcspn(p, " \t"); 
-		if (n > IFNAMSIZ) 
+		if (n > IFNAMSIZ-1) 
 			complain(_("interface name too long at line %d"), line);  
 		memcpy(ch->ifname, p, n); 
 		ch->ifname[n] = 0; 
@@ -200,7 +198,7 @@ struct option lopt[] = {
 
 void usage(void)
 {
-	fprintf(stderr, _("usage: nameif [-c configurationfile] [-s] {ifname macaddress}")); 
+	fprintf(stderr, _("usage: nameif [-c configurationfile] [-s] {ifname macaddress}\n")); 
 	exit(1); 
 }
 
@@ -277,21 +275,21 @@ int main(int ac, char **av)
 		ch = lookupmac(mac); 
 		if (!ch) 
 			continue;
-			
-		*ch->pprev = ch->next;
+		
+		ch->found = 1;	
 		if (strcmp(p, ch->ifname)) { 
 			if (setname(p, ch->ifname) < 0)  
 				complain(_("cannot change name of %s to %s: %s"),
 						p, ch->ifname, strerror(errno)); 
 		} 
-		free(ch);
 	} 
 	fclose(ifh); 
 	
 	while (clist) { 
 		struct change *ch = clist;
 		clist = clist->next;
-		warning(_("interface '%s' not found"), ch->ifname); 
+		if (!ch->found)
+			warning(_("interface '%s' not found"), ch->ifname); 
 		free(ch); 
 	}
 
diff --git a/netstat.c b/netstat.c
index 1ef790e..c3a7bb1 100644
--- a/netstat.c
+++ b/netstat.c
@@ -6,7 +6,7 @@
  *              NET-3 Networking Distribution for the LINUX operating
  *              system.
  *
- * Version:     $Id: netstat.c,v 1.43 2001/04/15 14:41:17 pb Exp $
+ * Version:     $Id: netstat.c,v 1.55 2007/12/01 19:00:40 ecki Exp $
  *
  * Authors:     Fred Baumgarten, <dc6iq@insu1.etec.uni-karlsruhe.de>
  *              Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>
@@ -94,6 +94,7 @@
 #include "sockets.h"
 #include "interface.h"
 #include "util.h"
+#include "proc.h"
 
 #define PROGNAME_WIDTH 20
 
@@ -104,6 +105,8 @@
 /* prototypes for statistics.c */
 void parsesnmp(int, int, int);
 void inittab(void);
+void parsesnmp6(int, int, int);
+void inittab6(void);
 
 typedef enum {
     SS_FREE = 0,		/* not allocated                */
@@ -146,6 +149,7 @@ int flag_udp = 0;
 int flag_igmp= 0;
 int flag_rom = 0;
 int flag_exp = 1;
+int flag_wide= 0;
 int flag_prg = 0;
 int flag_arg = 0;
 int flag_ver = 0;
@@ -153,7 +157,7 @@ int flag_ver = 0;
 FILE *procinfo;
 
 #define INFO_GUTS1(file,name,proc)			\
-  procinfo = fopen((file), "r");			\
+  procinfo = proc_fopen((file));			\
   if (procinfo == NULL) {				\
     if (errno != ENOENT) {				\
       perror((file));					\
@@ -174,7 +178,7 @@ FILE *procinfo;
 #if HAVE_AFINET6
 #define INFO_GUTS2(file,proc)				\
   lnr = 0;						\
-  procinfo = fopen((file), "r");		       	\
+  procinfo = proc_fopen((file));		       	\
   if (procinfo != NULL) {				\
     do {						\
       if (fgets(buffer, sizeof(buffer), procinfo))	\
@@ -216,7 +220,7 @@ FILE *procinfo;
 
 static struct prg_node {
     struct prg_node *next;
-    int inode;
+    unsigned long inode;
     char name[PROGNAME_WIDTH];
 } *prg_hash[PRG_HASH_SIZE];
 
@@ -249,7 +253,7 @@ static char prg_cache_loaded = 0;
 /* NOT working as of glibc-2.0.7: */
 #undef  DIRENT_HAVE_D_TYPE_WORKS
 
-static void prg_cache_add(int inode, char *name)
+static void prg_cache_add(unsigned long inode, char *name)
 {
     unsigned hi = PRG_HASHIT(inode);
     struct prg_node **pnp,*pn;
@@ -272,7 +276,7 @@ static void prg_cache_add(int inode, char *name)
     strcpy(pn->name,name);
 }
 
-static const char *prg_cache_get(int inode)
+static const char *prg_cache_get(unsigned long inode)
 {
     unsigned hi=PRG_HASHIT(inode);
     struct prg_node *pn;
@@ -295,55 +299,61 @@ static void prg_cache_clear(void)
     prg_cache_loaded=0;
 }
 
-static void extract_type_1_socket_inode(const char lname[], long * inode_p) {
+static int extract_type_1_socket_inode(const char lname[], unsigned long * inode_p) {
 
     /* If lname is of the form "socket:[12345]", extract the "12345"
        as *inode_p.  Otherwise, return -1 as *inode_p.
        */
 
-    if (strlen(lname) < PRG_SOCKET_PFXl+3) *inode_p = -1;
-    else if (memcmp(lname, PRG_SOCKET_PFX, PRG_SOCKET_PFXl)) *inode_p = -1;
-    else if (lname[strlen(lname)-1] != ']') *inode_p = -1;
-    else {
+    if (strlen(lname) < PRG_SOCKET_PFXl+3) return(-1);
+    
+    if (memcmp(lname, PRG_SOCKET_PFX, PRG_SOCKET_PFXl)) return(-1);
+    if (lname[strlen(lname)-1] != ']') return(-1);
+
+    {
         char inode_str[strlen(lname + 1)];  /* e.g. "12345" */
         const int inode_str_len = strlen(lname) - PRG_SOCKET_PFXl - 1;
         char *serr;
 
         strncpy(inode_str, lname+PRG_SOCKET_PFXl, inode_str_len);
         inode_str[inode_str_len] = '\0';
-        *inode_p = strtol(inode_str,&serr,0);
-        if (!serr || *serr || *inode_p < 0 || *inode_p >= INT_MAX) 
-            *inode_p = -1;
+        *inode_p = strtoul(inode_str,&serr,0);
+        if (!serr || *serr)
+            return(-1);
     }
+    return(0);
 }
 
 
 
-static void extract_type_2_socket_inode(const char lname[], long * inode_p) {
+static int extract_type_2_socket_inode(const char lname[], unsigned long * inode_p) {
 
     /* If lname is of the form "[0000]:12345", extract the "12345"
        as *inode_p.  Otherwise, return -1 as *inode_p.
        */
 
-    if (strlen(lname) < PRG_SOCKET_PFX2l+1) *inode_p = -1;
-    else if (memcmp(lname, PRG_SOCKET_PFX2, PRG_SOCKET_PFX2l)) *inode_p = -1;
-    else {
+    if (strlen(lname) < PRG_SOCKET_PFX2l+1) return(-1);
+    if (memcmp(lname, PRG_SOCKET_PFX2, PRG_SOCKET_PFX2l)) return(-1);
+
+    {
         char *serr;
 
-        *inode_p=strtol(lname + PRG_SOCKET_PFX2l,&serr,0);
-        if (!serr || *serr || *inode_p < 0 || *inode_p >= INT_MAX) 
-            *inode_p = -1;
+        *inode_p=strtoul(lname + PRG_SOCKET_PFX2l,&serr,0);
+        if (!serr || *serr)
+            return(-1);
     }
+    return(0);
 }
 
 
 
+
 static void prg_cache_load(void)
 {
     char line[LINE_MAX],eacces=0;
     int procfdlen,fd,cmdllen,lnamelen;
     char lname[30],cmdlbuf[512],finbuf[PROGNAME_WIDTH];
-    long inode;
+    unsigned long inode;
     const char *cs,*cmdlp;
     DIR *dirproc=NULL,*dirfd=NULL;
     struct dirent *direproc,*direfd;
@@ -377,6 +387,10 @@ static void prg_cache_load(void)
 #ifdef DIRENT_HAVE_D_TYPE_WORKS
 	    if (direfd->d_type!=DT_LNK) 
 		continue;
+#else
+	    /* Skip . and .. */
+	    if (!isdigit(direfd->d_name[0]))
+		continue;
 #endif
 	    if (procfdlen+1+strlen(direfd->d_name)+1>sizeof(line)) 
 		continue;
@@ -386,11 +400,9 @@ static void prg_cache_load(void)
 	    lnamelen=readlink(line,lname,sizeof(lname)-1);
             lname[lnamelen] = '\0';  /*make it a null-terminated string*/
 
-            extract_type_1_socket_inode(lname, &inode);
-
-            if (inode < 0) extract_type_2_socket_inode(lname, &inode);
-
-            if (inode < 0) continue;
+            if (extract_type_1_socket_inode(lname, &inode) < 0)
+              if (extract_type_2_socket_inode(lname, &inode) < 0)
+                continue;
 
 	    if (!cmdlp) {
 		if (procfdlen - PATH_FD_SUFFl + PATH_CMDLINEl >= 
@@ -450,7 +462,7 @@ static int netrom_info(void)
     char buffer[256], dev[16];
     int st, vs, vr, sendq, recvq, ret;
 
-    f = fopen(_PATH_PROCNET_NR, "r");
+    f = proc_fopen(_PATH_PROCNET_NR);
     if (f == NULL) {
 	if (errno != ENOENT) {
 	    perror(_PATH_PROCNET_NR);
@@ -527,15 +539,15 @@ static void finish_this_one(int uid, unsigned long inode, const char *timers)
 
     if (flag_exp > 1) {
 	if (!(flag_not & FLAG_NUM_USER) && ((pw = getpwuid(uid)) != NULL))
-	    printf("%-10s ", pw->pw_name);
+	    printf(" %-10s ", pw->pw_name);
 	else
-	    printf("%-10d ", uid);
-	printf("%-10ld ",inode);
+	    printf(" %-10d ", uid);
+	printf("%-10lu ",inode);
     }
     if (flag_prg)
-	printf("%-" PROGNAME_WIDTHs "s",prg_cache_get(inode));
+	printf(" %-16s",prg_cache_get(inode));
     if (flag_opt)
-	printf("%s", timers);
+	printf(" %s", timers);
     putchar('\n');
 }
 
@@ -646,7 +658,7 @@ static void igmp_do_one(int lnr, const char *line)
 #if HAVE_AFX25
 static int x25_info(void)
 {
-       FILE *f=fopen(_PATH_PROCNET_X25, "r");
+       FILE *f=proc_fopen(_PATH_PROCNET_X25);
        char buffer[256],dev[16];
        int st,vs,vr,sendq,recvq,lci;
        static char *x25_state[5]=
@@ -657,7 +669,7 @@ static int x25_info(void)
                "ESTABLISHED",
                "RECOVERY"
        };
-       if(!(f=fopen(_PATH_PROCNET_X25, "r")))
+       if(!(f=proc_fopen(_PATH_PROCNET_X25)))
        {
                if (errno != ENOENT) {
                        perror(_PATH_PROCNET_X25);
@@ -705,6 +717,7 @@ static void tcp_do_one(int lnr, const char *line)
     unsigned long rxq, txq, time_len, retr, inode;
     int num, local_port, rem_port, d, state, uid, timer_run, timeout;
     char rem_addr[128], local_addr[128], timers[64], buffer[1024], more[512];
+    char *protname;
     struct aftype *ap;
 #if HAVE_AFINET6
     struct sockaddr_in6 localaddr, remaddr;
@@ -719,12 +732,13 @@ static void tcp_do_one(int lnr, const char *line)
 	return;
 
     num = sscanf(line,
-    "%d: %64[0-9A-Fa-f]:%X %64[0-9A-Fa-f]:%X %X %lX:%lX %X:%lX %lX %d %d %ld %512s\n",
+    "%d: %64[0-9A-Fa-f]:%X %64[0-9A-Fa-f]:%X %X %lX:%lX %X:%lX %lX %d %d %lu %512s\n",
 		 &d, local_addr, &local_port, rem_addr, &rem_port, &state,
 		 &txq, &rxq, &timer_run, &time_len, &retr, &uid, &timeout, &inode, more);
 
     if (strlen(local_addr) > 8) {
 #if HAVE_AFINET6
+	protname = "tcp6";
 	/* Demangle what the kernel gives us */
 	sscanf(local_addr, "%08X%08X%08X%08X",
 	       &in6.s6_addr32[0], &in6.s6_addr32[1],
@@ -740,6 +754,7 @@ static void tcp_do_one(int lnr, const char *line)
 	remaddr.sin6_family = AF_INET6;
 #endif
     } else {
+	protname = "tcp";
 	sscanf(local_addr, "%X",
 	       &((struct sockaddr_in *) &localaddr)->sin_addr.s_addr);
 	sscanf(rem_addr, "%X",
@@ -772,16 +787,20 @@ static void tcp_do_one(int lnr, const char *line)
 		 get_sname(htons(local_port), "tcp",
 			   flag_not & FLAG_NUM_PORT));
 
-	if ((strlen(local_addr) + strlen(buffer)) > 22)
-	    local_addr[22 - strlen(buffer)] = '\0';
+	if (!flag_wide) {
+	    if ((strlen(local_addr) + strlen(buffer)) > 22)
+		local_addr[22 - strlen(buffer)] = '\0';
+	}
 
 	strcat(local_addr, ":");
 	strcat(local_addr, buffer);
 	snprintf(buffer, sizeof(buffer), "%s",
 		 get_sname(htons(rem_port), "tcp", flag_not & FLAG_NUM_PORT));
 
-	if ((strlen(rem_addr) + strlen(buffer)) > 22)
-	    rem_addr[22 - strlen(buffer)] = '\0';
+	if (!flag_wide) {
+	    if ((strlen(rem_addr) + strlen(buffer)) > 22)
+		rem_addr[22 - strlen(buffer)] = '\0';
+	}
 
 	strcat(rem_addr, ":");
 	strcat(rem_addr, buffer);
@@ -813,8 +832,8 @@ static void tcp_do_one(int lnr, const char *line)
 			 timer_run, (double) time_len / HZ, retr, timeout);
 		break;
 	    }
-	printf("tcp   %6ld %6ld %-23s %-23s %-12s",
-	       rxq, txq, local_addr, rem_addr, _(tcp_state[state]));
+	printf("%-4s  %6ld %6ld %-*s %-*s %-11s",
+	       protname, rxq, txq, netmax(23,strlen(local_addr)), local_addr, netmax(23,strlen(rem_addr)), rem_addr, _(tcp_state[state]));
 
 	finish_this_one(uid,inode,timers);
     }
@@ -831,6 +850,7 @@ static void udp_do_one(int lnr, const char *line)
     char buffer[8192], local_addr[64], rem_addr[64];
     char *udp_state, timers[64], more[512];
     int num, local_port, rem_port, d, state, timer_run, uid, timeout;
+    char *protname;
 #if HAVE_AFINET6
     struct sockaddr_in6 localaddr, remaddr;
     char addr6[INET6_ADDRSTRLEN];
@@ -847,13 +867,14 @@ static void udp_do_one(int lnr, const char *line)
 
     more[0] = '\0';
     num = sscanf(line,
-		 "%d: %64[0-9A-Fa-f]:%X %64[0-9A-Fa-f]:%X %X %lX:%lX %X:%lX %lX %d %d %ld %512s\n",
+		 "%d: %64[0-9A-Fa-f]:%X %64[0-9A-Fa-f]:%X %X %lX:%lX %X:%lX %lX %d %d %lu %512s\n",
 		 &d, local_addr, &local_port,
 		 rem_addr, &rem_port, &state,
 	  &txq, &rxq, &timer_run, &time_len, &retr, &uid, &timeout, &inode, more);
 
     if (strlen(local_addr) > 8) {
 #if HAVE_AFINET6
+	protname="udp6";
 	sscanf(local_addr, "%08X%08X%08X%08X",
 	       &in6.s6_addr32[0], &in6.s6_addr32[1],
 	       &in6.s6_addr32[2], &in6.s6_addr32[3]);
@@ -868,6 +889,7 @@ static void udp_do_one(int lnr, const char *line)
 	remaddr.sin6_family = AF_INET6;
 #endif
     } else {
+        protname="udp";
 	sscanf(local_addr, "%X",
 	       &((struct sockaddr_in *) &localaddr)->sin_addr.s_addr);
 	sscanf(rem_addr, "%X",
@@ -953,8 +975,8 @@ static void udp_do_one(int lnr, const char *line)
 			 retr, timeout);
 		break;
 	    }
-	printf("udp   %6ld %6ld %-23s %-23s %-12s",
-	       rxq, txq, local_addr, rem_addr, udp_state);
+	printf("%-4s  %6ld %6ld %-23s %-23s %-11s",
+	       protname, rxq, txq, local_addr, rem_addr, udp_state);
 
 	finish_this_one(uid,inode,timers);
     }
@@ -971,6 +993,7 @@ static void raw_do_one(int lnr, const char *line)
     char buffer[8192], local_addr[64], rem_addr[64];
     char timers[64], more[512];
     int num, local_port, rem_port, d, state, timer_run, uid, timeout;
+    char *protname;
 #if HAVE_AFINET6
     struct sockaddr_in6 localaddr, remaddr;
     char addr6[INET6_ADDRSTRLEN];
@@ -987,12 +1010,13 @@ static void raw_do_one(int lnr, const char *line)
 
     more[0] = '\0';
     num = sscanf(line,
-		 "%d: %64[0-9A-Fa-f]:%X %64[0-9A-Fa-f]:%X %X %lX:%lX %X:%lX %lX %d %d %ld %512s\n",
+		 "%d: %64[0-9A-Fa-f]:%X %64[0-9A-Fa-f]:%X %X %lX:%lX %X:%lX %lX %d %d %lu %512s\n",
 		 &d, local_addr, &local_port, rem_addr, &rem_port, &state,
 	  &txq, &rxq, &timer_run, &time_len, &retr, &uid, &timeout, &inode, more);
 
     if (strlen(local_addr) > 8) {
 #if HAVE_AFINET6
+	protname = "raw6";
 	sscanf(local_addr, "%08X%08X%08X%08X",
 	       &in6.s6_addr32[0], &in6.s6_addr32[1],
            &in6.s6_addr32[2], &in6.s6_addr32[3]);
@@ -1007,6 +1031,7 @@ static void raw_do_one(int lnr, const char *line)
 	remaddr.sin6_family = AF_INET6;
 #endif
     } else {
+        protname = "raw";
 	sscanf(local_addr, "%X",
 	       &((struct sockaddr_in *) &localaddr)->sin_addr.s_addr);
 	sscanf(rem_addr, "%X",
@@ -1074,8 +1099,8 @@ static void raw_do_one(int lnr, const char *line)
 			 retr, timeout);
 		break;
 	    }
-	printf("raw   %6ld %6ld %-23s %-23s %-12d",
-	       rxq, txq, local_addr, rem_addr, state);
+	printf("%-4s  %6ld %6ld %-23s %-23s %-11d",
+	       protname, rxq, txq, local_addr, rem_addr, state);
 
 	finish_this_one(uid,inode,timers);
     }
@@ -1099,9 +1124,9 @@ static void unix_do_one(int nr, const char *line)
     static int has = 0;
     char path[MAXPATHLEN], ss_flags[32];
     char *ss_proto, *ss_state, *ss_type;
-    int num, state, type, inode;
+    int num, state, type;
     void *d;
-    unsigned long refcnt, proto, flags;
+    unsigned long refcnt, proto, flags, inode;
 
     if (nr == 0) {
 	if (strstr(line, "Inode"))
@@ -1109,14 +1134,14 @@ static void unix_do_one(int nr, const char *line)
 	return;
     }
     path[0] = '\0';
-    num = sscanf(line, "%p: %lX %lX %lX %X %X %d %s",
+    num = sscanf(line, "%p: %lX %lX %lX %X %X %lu %s",
 		 &d, &refcnt, &proto, &flags, &type, &state, &inode, path);
     if (num < 6) {
 	fprintf(stderr, _("warning, got bogus unix line.\n"));
 	return;
     }
     if (!(has & HAS_INODE))
-	snprintf(path,sizeof(path),"%d",inode);
+	snprintf(path,sizeof(path),"%lu",inode);
 
     if (!flag_all) {
     	if ((state == SS_UNCONNECTED) && (flags & SO_ACCEPTCON)) {
@@ -1208,9 +1233,9 @@ static void unix_do_one(int nr, const char *line)
     printf("%-5s %-6ld %-11s %-10s %-13s ",
 	   ss_proto, refcnt, ss_flags, ss_type, ss_state);
     if (has & HAS_INODE)
-	printf("%-6d ",inode);
+	printf("%-8lu ",inode);
     else
-	printf("-      ");
+	printf("-        ");
     if (flag_prg)
 	printf("%-" PROGNAME_WIDTHs "s",(has & HAS_INODE?prg_cache_get(inode):"-"));
     puts(path);
@@ -1229,7 +1254,7 @@ static int unix_info(void)
 	printf(_("(w/o servers)"));
     }
 
-    printf(_("\nProto RefCnt Flags       Type       State         I-Node"));
+    printf(_("\nProto RefCnt Flags       Type       State         I-Node  "));
     print_progname_banner();
     printf(_(" Path\n"));	/* xxx */
 
@@ -1256,7 +1281,7 @@ static int ax25_info(void)
 	N_("ESTABLISHED"),
 	N_("RECOVERY")
     };
-    if (!(f = fopen(_PATH_PROCNET_AX25, "r"))) {
+    if (!(f = proc_fopen(_PATH_PROCNET_AX25))) {
 	if (errno != ENOENT) {
 	    perror(_PATH_PROCNET_AX25);
 	    return (-1);
@@ -1350,18 +1375,37 @@ static int ipx_info(void)
     char sad[50], dad[50];
     struct sockaddr sa;
     unsigned sport = 0, dport = 0;
-
-    if (!(f = fopen(_PATH_PROCNET_IPX, "r"))) {
-	if (errno != ENOENT) {
-	    perror(_PATH_PROCNET_IPX);
-	    return (-1);
-	}
-	if (flag_arg || flag_ver)
-	    ESYSNOT("netstat", "AF IPX");
-	if (flag_arg)
-	    return (1);
-	else
-	    return (0);
+    struct stat s;
+    
+    f = proc_fopen(_PATH_PROCNET_IPX_SOCKET1);
+    if (!f) {
+        if (errno != ENOENT) {
+            perror(_PATH_PROCNET_IPX_SOCKET1);
+            return (-1);
+        }
+        f = proc_fopen(_PATH_PROCNET_IPX_SOCKET2);
+
+        /* We need to check for directory */
+        if (f) {
+            fstat(fileno(f), &s);
+            if (!S_ISREG(s.st_mode)) {
+                fclose(f);
+                f=NULL;
+            }
+        }
+
+        if (!f) {
+            if (errno != ENOENT) {
+	        perror(_PATH_PROCNET_IPX_SOCKET2);
+	        return (-1);
+	    }
+	    if (flag_arg || flag_ver)
+	        ESYSNOT("netstat", "AF IPX");
+	    if (flag_arg)
+	        return (1);
+ 	    else
+	        return (0);
+        }
     }
     printf(_("Active IPX sockets\nProto Recv-Q Send-Q Local Address              Foreign Address            State"));	/* xxx */
     if (flag_exp > 1)
@@ -1381,7 +1425,7 @@ static int ipx_info(void)
 	    sscanf(st, "%X", &sport);	/* net byt order */
 	    sport = ntohs(sport);
 	} else {
-	    EINTERN("netstat.c", _PATH_PROCNET_IPX " sport format error");
+	    EINTERN("netstat.c", "ipx socket format error in source port");
 	    return (-1);
 	}
 	nc = 0;
@@ -1391,7 +1435,7 @@ static int ipx_info(void)
 		sscanf(st, "%X", &dport);	/* net byt order */
 		dport = ntohs(dport);
 	    } else {
-		EINTERN("netstat.c", _PATH_PROCNET_IPX " dport format error");
+		EINTERN("netstat.c", "ipx soket format error in destination port");
 		return (-1);
 	    }
 	} else
@@ -1449,7 +1493,7 @@ static int iface_info(void)
     }
     if (flag_exp < 2) {
 	ife_short = 1;
-	printf(_("Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR   TX-OK TX-ERR TX-DRP TX-OVR Flg\n"));
+	printf(_("Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\n"));
     }
 
     if (for_all_interfaces(do_if_print, &flag_all) < 0) {
@@ -1457,7 +1501,7 @@ static int iface_info(void)
 	exit(1);
     }
     if (flag_cnt)
-	free_interface_list();
+	if_cache_free();
     else {
 	close(skfd);
 	skfd = -1;
@@ -1476,9 +1520,9 @@ static void version(void)
 
 static void usage(void)
 {
-    fprintf(stderr, _("usage: netstat [-veenNcCF] [<Af>] -r         netstat {-V|--version|-h|--help}\n"));
-    fprintf(stderr, _("       netstat [-vnNcaeol] [<Socket> ...]\n"));
-    fprintf(stderr, _("       netstat { [-veenNac] -i | [-cnNe] -M | -s }\n\n"));
+    fprintf(stderr, _("usage: netstat [-vWeenNcCF] [<Af>] -r         netstat {-V|--version|-h|--help}\n"));
+    fprintf(stderr, _("       netstat [-vWnNcaeol] [<Socket> ...]\n"));
+    fprintf(stderr, _("       netstat { [-vWeenNac] -i | [-cWnNe] -M | -s }\n\n"));
 
     fprintf(stderr, _("        -r, --route              display routing table\n"));
     fprintf(stderr, _("        -i, --interfaces         display interface table\n"));
@@ -1488,6 +1532,7 @@ static void usage(void)
     fprintf(stderr, _("        -M, --masquerade         display masqueraded connections\n\n"));
 #endif
     fprintf(stderr, _("        -v, --verbose            be verbose\n"));
+    fprintf(stderr, _("        -W, --wide               don't truncate IP addresses\n"));
     fprintf(stderr, _("        -n, --numeric            don't resolve names\n"));
     fprintf(stderr, _("        --numeric-hosts          don't resolve host names\n"));
     fprintf(stderr, _("        --numeric-ports          don't resolve port names\n"));
@@ -1503,7 +1548,7 @@ static void usage(void)
     fprintf(stderr, _("        -C, --cache              display routing cache instead of FIB\n\n"));
 
     fprintf(stderr, _("  <Socket>={-t|--tcp} {-u|--udp} {-w|--raw} {-x|--unix} --ax25 --ipx --netrom\n"));
-    fprintf(stderr, _("  <AF>=Use '-A <af>' or '--<af>'; default: %s\n"), DFLT_AF);
+    fprintf(stderr, _("  <AF>=Use '-6|-4' or '-A <af>' or '--<af>'; default: %s\n"), DFLT_AF);
     fprintf(stderr, _("  List of possible address families (which support routing):\n"));
     print_aflist(1); /* 1 = routeable */
     exit(E_USAGE);
@@ -1514,7 +1559,7 @@ int main
  (int argc, char *argv[]) {
     int i;
     int lop;
-    struct option longopts[] =
+    static struct option longopts[] =
     {
 	AFTRANS_OPTS,
 	{"version", 0, 0, 'V'},
@@ -1537,6 +1582,7 @@ int main
 	{"programs", 0, 0, 'p'},
 	{"verbose", 0, 0, 'v'},
 	{"statistics", 0, 0, 's'},
+	{"wide", 0, 0, 'W'},
 	{"numeric", 0, 0, 'n'},
 	{"numeric-hosts", 0, 0, '!'},
 	{"numeric-ports", 0, 0, '@'},
@@ -1556,7 +1602,7 @@ int main
     getroute_init();		/* Set up AF routing support */
 
     afname[0] = '\0';
-    while ((i = getopt_long(argc, argv, "MCFA:acdegphinNorstuVv?wxl", longopts, &lop)) != EOF)
+    while ((i = getopt_long(argc, argv, "MCFA:acdegphinNorstuWVv?wxl64", longopts, &lop)) != EOF)
 	switch (i) {
 	case -1:
 	    break;
@@ -1600,6 +1646,9 @@ int main
 	case 'i':
 	    flag_int++;
 	    break;
+	case 'W':
+	    flag_wide++;
+	    break;
 	case 'n':
 	    flag_not |= FLAG_NUM;
 	    break;
@@ -1624,6 +1673,14 @@ int main
 	case 'o':
 	    flag_opt++;
 	    break;
+	case '6':
+	    if (aftrans_opt("inet6"))
+		exit(1);
+	    break;
+	case '4':
+	    if (aftrans_opt("inet"))
+		exit(1);
+	    break;
 	case 'V':
 	    version();
 	    /*NOTREACHED */
@@ -1688,9 +1745,28 @@ int main
     }
 
     if (flag_sta) {
-        inittab();
-	parsesnmp(flag_raw, flag_tcp, flag_udp);
-	exit(0);
+        char *tmp1, *tmp2;
+        char buf[256];
+        if (!afname[0]) {
+            inittab();
+            parsesnmp(flag_raw, flag_tcp, flag_udp);
+        } else {
+            safe_strncpy(buf, afname, sizeof(buf));
+            tmp1 = buf;
+            if ((tmp2 = index(tmp1, ',')))
+                 printf("Multiple interface\n");
+            else if(!strncmp(buf,"inet6",5)) {
+#if HAVE_AFINET6
+                 inittab6();
+                 parsesnmp6(flag_raw, flag_tcp, flag_udp);
+#else
+                 printf("Address type not supported for stats\n");
+#endif
+            }
+            else
+                 printf("Address type not supported for stats\n");
+        }
+        exit(1);
     }
     
     if (flag_rou) {
@@ -1741,10 +1817,11 @@ int main
 	    }
 	    printf(_("\nProto Recv-Q Send-Q Local Address           Foreign Address         State      "));	/* xxx */
 	    if (flag_exp > 1)
-		printf(_(" User       Inode     "));
-	    print_progname_banner();
+		printf(_(" User       Inode      "));
+            if (flag_prg)
+                printf(_(" PID/Program name"));
 	    if (flag_opt)
-		printf(_(" Timer"));	/* xxx */
+		printf(_(" Timer"));
 	    printf("\n");
 #else
 	    if (flag_arg) {
@@ -1845,6 +1922,7 @@ int main
 	    }
 #endif
 	}
+	            
 	if (!flag_cnt || i)
 	    break;
 	sleep(1);
diff --git a/po/Makefile b/po/Makefile
index 0fdf82d..c4648ee 100644
--- a/po/Makefile
+++ b/po/Makefile
@@ -3,7 +3,7 @@ INSTALL_PROGRAM= ${INSTALL}
 INSTALL_DATA= ${INSTALL} -m 644
 INSTALLNLSDIR=${BASEDIR}/usr/share/locale
 
-TUPDATE = tupdate
+TUPDATE = msgmerge
 
 NLSPACKAGE = net-tools
 
@@ -49,7 +49,7 @@ update-po: Makefile
 		lang=`echo $$cat | sed 's/.mo//'`; \
 		mv $$lang.po $$lang.old.po; \
 		echo "$$lang:"; \
-		if $(TUPDATE) $(NLSPACKAGE).pot $$lang.old.po > $$lang.po; then \
+		if $(TUPDATE) $$lang.old.po $(NLSPACKAGE).pot > $$lang.po; then \
 		rm -f $$lang.old.po; \
 	else \
 	 	echo "tupdate for $$cat failed!"; \
diff --git a/rarp.c b/rarp.c
index aab05b3..73f8731 100644
--- a/rarp.c
+++ b/rarp.c
@@ -3,7 +3,7 @@
  *              that maintains the kernel's RARP cache.  It is derived
  *              from Fred N. van Kempen's arp command.
  *
- * Version:	$Id: rarp.c,v 1.6 2001/04/08 17:05:05 pb Exp $
+ * Version:	$Id: rarp.c,v 1.9 2007/12/02 02:19:52 ecki Exp $
  *
  * Usage:       rarp -d hostname                      Delete entry
  *              rarp -s hostname ethernet_address     Add entry
@@ -40,6 +40,7 @@
 #include "net-support.h"
 #include "version.h"
 #include "pathnames.h"
+#include "proc.h"
 
 static char no_rarp_message[] = N_("This kernel does not support RARP.\n");
 
@@ -154,7 +155,7 @@ static int rarp_file(int fd, const char *name)
 
 static int display_cache(void)
 {
-    FILE *fd = fopen(_PATH_PROCNET_RARP, "r");
+    FILE *fd = proc_fopen(_PATH_PROCNET_RARP);
     char buffer[256];
     if (fd == NULL) {
 	if (errno == ENOENT)
diff --git a/route.c b/route.c
index f8c2bc3..d7029f7 100644
--- a/route.c
+++ b/route.c
@@ -2,7 +2,7 @@
  * route        This file contains an implementation of the command
  *              that manages the IP routing table in the kernel.
  *
- * Version:     $Id: route.c,v 1.9 2001/04/15 14:41:17 pb Exp $
+ * Version:     $Id: route.c,v 1.10 2002/07/30 05:24:20 ecki Exp $
  *
  * Maintainer:  Bernd 'eckes' Eckenfels, <net-tools@lina.inka.de>
  *
@@ -142,7 +142,7 @@ int main(int argc, char **argv)
     }
 
     /* Fetch the command-line arguments. */
-    while ((i = getopt_long(argc, argv, "A:eCFhnNVv?", longopts, &lop)) != EOF)
+    while ((i = getopt_long(argc, argv, "A:eCFhnN64Vv?", longopts, &lop)) != EOF)
 	switch (i) {
 	case -1:
 	    break;
@@ -176,6 +176,14 @@ int main(int argc, char **argv)
 	    if ((i = aftrans_opt(optarg)))
 		exit(i);
 	    break;
+	case '6':
+	    if ((i = aftrans_opt("inet6")))
+		exit(i);
+	    break;
+	case '4':
+	    if ((i = aftrans_opt("inet")))
+		exit(i);
+	    break;
 	case 'V':
 	    version();
 	case 'h':
diff --git a/slattach.c b/slattach.c
index cedae1b..2e50896 100644
--- a/slattach.c
+++ b/slattach.c
@@ -73,7 +73,7 @@
 
 
 const char *Release = RELEASE,
-	   *Version = "@(#) slattach 1.21 (1999-11-21)",
+	   *Version = "$Id: slattach.c,v 1.11 2005/12/04 05:15:36 ecki Exp $",
 	   *Signature = "net-tools, Fred N. van Kempen et al.";
 
 
@@ -115,7 +115,7 @@ int		opt_h = 0;		/* "hangup" on carrier loss	*/
 int		opt_k = 0;		/* "keepalive" value		*/
 #endif
 int		opt_l = 0;		/* "lock it" flag		*/
-int		opt_L = 0;		/* clocal flag			*/
+int		opt_L = 0;		/* 3-wire mode flag		*/
 int		opt_m = 0;		/* "set RAW mode" flag		*/
 int		opt_n = 0;		/* "set No Mesg" flag		*/
 #ifdef SIOCSOUTFILL
@@ -342,9 +342,11 @@ tty_set_raw(struct termios *tty)
   tty->c_oflag = (0);				/* output flags		*/
   tty->c_lflag = (0);				/* local flags		*/
   speed = (tty->c_cflag & CBAUD);		/* save current speed	*/
-  tty->c_cflag = (CRTSCTS | HUPCL | CREAD);	/* UART flags		*/
+  tty->c_cflag = (HUPCL | CREAD);		/* UART flags		*/
   if (opt_L) 
 	tty->c_cflag |= CLOCAL;
+  else
+	tty->c_cflag |= CRTSCTS;
   tty->c_cflag |= speed;			/* restore speed	*/
   return(0);
 }
diff --git a/statistics.c b/statistics.c
index a878df8..03600d7 100644
--- a/statistics.c
+++ b/statistics.c
@@ -1,6 +1,6 @@
 /*
  * Copyright 1997,1999,2000 Andi Kleen. Subject to the GPL. 
- * $Id: statistics.c,v 1.14 2001/02/02 18:01:23 pb Exp $
+ * $Id: statistics.c,v 1.21 2008/10/03 00:05:20 ecki Exp $
  * 19980630 - i18n - Arnaldo Carvalho de Melo <acme@conectiva.com.br> 
  * 19981113 - i18n fixes - Arnaldo Carvalho de Melo <acme@conectiva.com.br> 
  * 19990101 - added net/netstat, -t, -u, -w supprt - Bernd Eckenfels 
@@ -11,6 +11,7 @@
 #include <string.h>
 #include "config.h"
 #include "intl.h"
+#include "proc.h"
 
 /* #define WARN 1 */
 
@@ -83,6 +84,32 @@ struct entry Iptab[] =
     {"FragCreates", N_("%u fragments created"), opt_number}
 };
 
+struct entry Ip6tab[] =
+{
+    {"Ip6InReceives", N_("%u total packets received"), number},
+    {"Ip6InHdrErrors", N_("%u with invalid headers"), opt_number},
+    {"Ip6InTooBigErrors", N_("%u with packets too big"), opt_number},
+    {"Ip6InNoRoutes", N_("%u incoming packets with no route"), opt_number},
+    {"Ip6InAddrErrors", N_("%u with invalid addresses"), opt_number},
+    {"Ip6InUnknownProtos", N_("%u with unknown protocol"), opt_number},
+    {"Ip6InTruncatedPkts", N_("%u with truncated packets"), opt_number},
+    {"Ip6InDiscards", N_("%u incoming packets discarded"), number},
+    {"Ip6InDelivers", N_("%u incoming packets delivered"), number},
+    {"Ip6OutForwDatagrams", N_("%u forwarded"), number},
+    {"Ip6OutRequests", N_("%u requests sent out"), number},     /*? */
+    {"Ip6OutDiscards", N_("%u outgoing packets dropped"), opt_number},
+    {"Ip6OutNoRoutes", N_("%u dropped because of missing route"), opt_number},
+    {"Ip6ReasmTimeout", N_("%u fragments dropped after timeout"), opt_number},
+    {"Ip6ReasmReqds", N_("%u reassemblies required"), opt_number}, /* ? */
+    {"Ip6ReasmOKs", N_("%u packets reassembled ok"), opt_number},
+    {"Ip6ReasmFails", N_("%u packet reassembles failed"), opt_number},
+    {"Ip6FragOKs", N_("%u fragments received ok"), opt_number},
+    {"Ip6FragFails", N_("%u fragments failed"), opt_number},
+    {"Ip6FragCreates", N_("%u fragments created"), opt_number},
+    {"Ip6InMcastPkts", N_("%u incoming multicast packets"), opt_number},
+    {"Ip6OutMcastPkts", N_("%u outgoing multicast packets"), opt_number}
+};
+
 struct entry Icmptab[] =
 {
     {"InMsgs", N_("%u ICMP messages received"), number},
@@ -113,6 +140,41 @@ struct entry Icmptab[] =
     {"OutAddrMaskReps", N_("address mask replies: %u"), i_outp_icmp | I_TITLE},
 };
 
+struct entry Icmp6tab[] =
+{
+    {"Icmp6InMsgs", N_("%u ICMP messages received"), number},
+    {"Icmp6InErrors", N_("%u input ICMP message failed."), number},
+    {"Icmp6InDestUnreachs", N_("destination unreachable: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InPktTooBigs", N_("packets too big: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InTimeExcds", N_("received ICMPv6 time exceeded: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InParmProblems", N_("parameter problem: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InEchos", N_("echo requests: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InEchoReplies", N_("echo replies: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InGroupMembQueries", N_("group member queries: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InGroupMembResponses", N_("group member responses: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InGroupMembReductions", N_("group member reductions: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InRouterSolicits", N_("router solicits: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InRouterAdvertisements", N_("router advertisement: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InNeighborSolicits", N_("neighbour solicits: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InNeighborAdvertisements", N_("neighbour advertisement: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6InRedirects", N_("redirects: %u"), i_inp_icmp | I_TITLE},
+    {"Icmp6OutMsgs", N_("%u ICMP messages sent"), number},
+    {"Icmp6OutDestUnreachs", N_("destination unreachable: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutPktTooBigs", N_("packets too big: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutTimeExcds", N_("sent ICMPv6 time exceeded: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutParmProblems", N_("parameter problem: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutEchos", N_("echo requests: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutEchoReplies", N_("echo replies: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutGroupMembQueries", N_("group member queries: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutGroupMembResponses", N_("group member responses: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutGroupMembReductions", N_("group member reductions: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutRouterSolicits", N_("router solicits: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutRouterAdvertisements ", N_("router advertisement: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutNeighborSolicits", N_("neighbor solicits: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutNeighborAdvertisements", N_("neighbor advertisements: %u"), i_outp_icmp | I_TITLE},
+    {"Icmp6OutRedirects", N_("redirects: %u"), i_outp_icmp | I_TITLE},
+};
+
 struct entry Tcptab[] =
 {
     {"RtoAlgorithm", N_("RTO algorithm is %s"), i_rto_alg | I_STATIC},
@@ -139,6 +201,14 @@ struct entry Udptab[] =
     {"OutDatagrams", N_("%u packets sent"), number},
 };
 
+struct entry Udp6tab[] =
+{
+    {"Udp6InDatagrams", N_("%u packets received"), number},
+    {"Udp6NoPorts", N_("%u packets to unknown port received."), number},
+    {"Udp6InErrors", N_("%u packet receive errors"), number},
+    {"Udp6OutDatagrams", N_("%u packets sent"), number},
+};
+
 struct entry Tcpexttab[] =
 {
     {"SyncookiesSent", N_("%u SYN cookies sent"), opt_number},
@@ -172,19 +242,59 @@ struct entry Tcpexttab[] =
     { "DelayedACKLost", N_("Quick ack mode was activated %u times"), opt_number },
     { "ListenOverflows", N_("%u times the listen queue of a socket overflowed"),
       opt_number },
-    { "ListenDrops", N_("%u SYNs to LISTEN sockets ignored"), opt_number },
+    { "ListenDrops", N_("%u SYNs to LISTEN sockets dropped"), opt_number },
     { "TCPPrequeued", N_("%u packets directly queued to recvmsg prequeue."), 
       opt_number },
-    { "TCPDirectCopyFromBacklog", N_("%u packets directly received"
-				     " from backlog"), opt_number },
-    { "TCPDirectCopyFromPrequeue", N_("%u packets directly received"
-				      " from prequeue"), opt_number },
+    { "TCPDirectCopyFromBacklog", N_("%u bytes directly in process context from backlog"), opt_number },
+    { "TCPDirectCopyFromPrequeue", N_("%u bytes directly received in process context from prequeue"),
+				      opt_number },
     { "TCPPrequeueDropped", N_("%u packets dropped from prequeue"), opt_number },
-    { "TCPHPHits", N_("%u packets header predicted"), number },
+    { "TCPHPHits", N_("%u packet headers predicted"), number },
     { "TCPHPHitsToUser", N_("%u packets header predicted and "
 			    "directly queued to user"), opt_number },
     { "SockMallocOOM", N_("Ran %u times out of system memory during " 
 			  "packet sending"), opt_number }, 
+    { "TCPPureAcks", N_("%u acknowledgments not containing data payload received"), opt_number },
+    { "TCPHPAcks", N_("%u predicted acknowledgments"), opt_number },
+    { "TCPRenoRecovery", N_("%u times recovered from packet loss due to fast retransmit"), opt_number },
+    { "TCPSackRecovery", N_("%u times recovered from packet loss by selective acknowledgements"), opt_number },
+    { "TCPSACKReneging", N_("%u bad SACK blocks received"), opt_number },
+    { "TCPFACKReorder", N_("Detected reordering %u times using FACK"), opt_number },
+    { "TCPSACKReorder", N_("Detected reordering %u times using SACK"), opt_number },
+    { "TCPTSReorder", N_("Detected reordering %u times using time stamp"), opt_number },
+    { "TCPRenoReorder", N_("Detected reordering %u times using reno fast retransmit"), opt_number },
+    { "TCPFullUndo", N_("%u congestion windows fully recovered without slow start"), opt_number }, 
+    { "TCPPartialUndo", N_("%u congestion windows partially recovered using Hoe heuristic"), opt_number },
+    { "TCPDSackUndo", N_("%u congestion window recovered without slow start using DSACK"), opt_number },
+    { "TCPLossUndo", N_("%u congestion windows recovered without slow start after partial ack"), opt_number },
+    { "TCPLostRetransmits", N_("%u retransmits lost"), opt_number },
+    { "TCPRenoFailures",  N_("%u timeouts after reno fast retransmit"), opt_number },
+    { "TCPSackFailures",  N_("%u timeouts after SACK recovery"), opt_number },
+    { "TCPLossFailures",  N_("%u timeouts in loss state"), opt_number },
+    { "TCPFastRetrans", N_("%u fast retransmits"), opt_number },
+    { "TCPForwardRetrans", N_("%u forward retransmits"), opt_number }, 
+    { "TCPSlowStartRetrans", N_("%u retransmits in slow start"), opt_number },
+    { "TCPTimeouts", N_("%u other TCP timeouts"), opt_number },
+    { "TCPRenoRecoveryFailed", N_("%u reno fast retransmits failed"), opt_number },
+    { "TCPSackRecoveryFail", N_("%u SACK retransmits failed"), opt_number },
+    { "TCPSchedulerFailed", N_("%u times receiver scheduled too late for direct processing"), opt_number },
+    { "TCPRcvCollapsed", N_("%u packets collapsed in receive queue due to low socket buffer"), opt_number },
+    { "TCPDSACKOldSent", N_("%u DSACKs sent for old packets"), opt_number },
+    { "TCPDSACKOfoSent", N_("%u DSACKs sent for out of order packets"), opt_number },
+    { "TCPDSACKRecv", N_("%u DSACKs received"), opt_number },
+    { "TCPDSACKOfoRecv", N_("%u DSACKs for out of order packets received"), opt_number },
+    { "TCPAbortOnSyn", N_("%u connections reset due to unexpected SYN"), opt_number },
+    { "TCPAbortOnData", N_("%u connections reset due to unexpected data"), opt_number },
+    { "TCPAbortOnClose", N_("%u connections reset due to early user close"), opt_number },
+    { "TCPAbortOnMemory", N_("%u connections aborted due to memory pressure"), opt_number },
+    { "TCPAbortOnTimeout", N_("%u connections aborted due to timeout"), opt_number },
+    { "TCPAbortOnLinger", N_("%u connections aborted after user close in linger timeout"), opt_number },
+    { "TCPAbortFailed", N_("%u times unabled to send RST due to no memory"), opt_number }, 
+    { "TCPMemoryPressures", N_("TCP ran low on memory %u times"), opt_number }, 
+    { "TCPLoss", N_("%u TCP data loss events"), opt_number },
+    { "TCPDSACKUndo", N_("%u congestion windows recovered without slow start by DSACK"), 
+	opt_number },
+    { "TCPRenoRecoveryFail", N_("%u classic Reno fast retransmits failed"), opt_number },
 };
 
 struct tabtab {
@@ -204,6 +314,15 @@ struct tabtab snmptabs[] =
     {NULL}
 };
 
+struct tabtab snmp6tabs[] =
+{
+    {"Ip6", Ip6tab, sizeof(Ip6tab), &f_raw},
+    {"Icmp6", Icmp6tab, sizeof(Icmp6tab), &f_raw},
+    {"Udp6", Udp6tab, sizeof(Udp6tab), &f_udp},
+    {"Tcp6", Tcptab, sizeof(Tcptab), &f_tcp},
+    {NULL}
+};
+
 /* XXX IGMP */
 
 int cmpentries(const void *a, const void *b)
@@ -222,7 +341,8 @@ void printval(struct tabtab *tab, char *title, int val)
 	    ent = bsearch(&key, tab->tab, tab->size / sizeof(struct entry),
 			  sizeof(struct entry), cmpentries);
     if (!ent) {			/* try our best */
-	printf("%*s%s: %d\n", states[state].indent, "", title, val);
+	if (val) 
+		printf("%*s%s: %d\n", states[state].indent, "", title, val);
 	return;
     }
     type = ent->type;
@@ -289,14 +409,17 @@ struct tabtab *newtable(struct tabtab *tabs, char *title)
 	return &dummytab;
 }
 
-void process_fd(FILE *f)
+int process_fd(FILE *f, int all, char *filter)
 {
-    char buf1[1024], buf2[1024];
+    char buf1[2048], buf2[2048];
     char *sp, *np, *p;
     while (fgets(buf1, sizeof buf1, f)) {
 	int endflag;
 	struct tabtab *tab;
 
+        if (buf1[0] == '\n') // skip empty first line in 2.6 kernels
+            continue;
+            
 	if (!fgets(buf2, sizeof buf2, f))
 	    break;
 	sp = strchr(buf1, ':');
@@ -305,6 +428,10 @@ void process_fd(FILE *f)
 	    goto formaterr;
 	*sp = '\0';
 
+        if (!all)
+           if (strncmp(buf1, filter, strlen(filter)))
+               continue;
+
 	tab = newtable(snmptabs, buf1);
 	if (tab == NULL) {
 		printf("unknown %s\n", buf1);
@@ -330,13 +457,47 @@ void process_fd(FILE *f)
 	    sp = p + 1;
 	}
     }
-  return;
+  return 0;
   
 formaterr:
-  perror(_("error parsing /proc/net/snmp"));
-  return;
+  return -1;
+}
+
+void cpytitle(char *original, char *new)
+{
+     char *ptr = original;
+     while(*ptr != '6' && *ptr != '\0') {
+           *new = *ptr;
+            new++;
+            ptr++;
+     }
+    *new = *ptr;
+    new++;
+    *new = '\0';
 }
 
+void process6_fd(FILE *f)
+{
+   char buf1[1024],buf2[50],buf3[1024];
+   unsigned long val;
+   struct tabtab *tab = NULL;
+   int cpflg = 0;
+
+   while (fgets(buf1, sizeof buf1, f)) {
+          sscanf(buf1, "%s %lu", buf2, &val);
+          if(!cpflg) {
+             cpytitle(buf2, buf3);
+             tab = newtable(snmp6tabs, buf3);
+             cpflg = 1;
+          }
+          if(!strstr(buf2, buf3)) {
+             cpytitle(buf2, buf3);
+             tab = newtable(snmp6tabs, buf3);
+          }
+          printval(tab, buf2, val);
+   }
+
+}
 
 void parsesnmp(int flag_raw, int flag_tcp, int flag_udp)
 {
@@ -344,22 +505,25 @@ void parsesnmp(int flag_raw, int flag_tcp, int flag_udp)
 
     f_raw = flag_raw; f_tcp = flag_tcp; f_udp = flag_udp;
     
-    f = fopen("/proc/net/snmp", "r");
+    f = proc_fopen("/proc/net/snmp");
     if (!f) {
 	perror(_("cannot open /proc/net/snmp"));
 	return;
     }
-    process_fd(f);
+
+    if (process_fd(f, 1, NULL) < 0)
+      fprintf(stderr, _("Problem while parsing /proc/net/snmp\n"));
 
     if (ferror(f))
 	perror("/proc/net/snmp");
 
     fclose(f);
 
-    f = fopen("/proc/net/netstat", "r");
+    f = proc_fopen("/proc/net/netstat");
 
     if (f) {
-    	process_fd(f);
+    	if (process_fd(f, 1, NULL) <0)
+          fprintf(stderr, _("Problem while parsing /proc/net/netstat\n"));
 
         if (ferror(f))
 	    perror("/proc/net/netstat");
@@ -369,6 +533,33 @@ void parsesnmp(int flag_raw, int flag_tcp, int flag_udp)
     return;
 }
     
+void parsesnmp6(int flag_raw, int flag_tcp, int flag_udp)
+{
+    FILE *f;
+
+    f_raw = flag_raw; f_tcp = flag_tcp; f_udp = flag_udp;
+
+    f = fopen("/proc/net/snmp6", "r");
+    if (!f) {
+        perror(_("cannot open /proc/net/snmp6"));
+        return;
+    }
+    process6_fd(f);
+    if (ferror(f))
+        perror("/proc/net/snmp6");
+
+    fclose(f);
+    f = fopen("/proc/net/snmp", "r");
+    if (!f) {
+        perror(_("cannot open /proc/net/snmp"));
+        return;
+    }
+    process_fd(f, 0, "Tcp");
+    if (ferror(f))
+        perror("/proc/net/snmp");
+
+    fclose(f);
+}
 
 void inittab(void)
 {
@@ -379,3 +570,13 @@ void inittab(void)
 	qsort(t->tab, t->size / sizeof(struct entry),
 	      sizeof(struct entry), cmpentries);
 }
+
+void inittab6(void)
+{
+    struct tabtab *t;
+
+    for (t = snmp6tabs; t->title; t++)
+        qsort(t->tab, t->size / sizeof(struct entry),
+              sizeof(struct entry), cmpentries);
+}
+
-- 
1.7.0

